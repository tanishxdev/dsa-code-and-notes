# STRING SERIES

## Topic: Valid Palindrome

(LeetCode #125)

---

## **1. Problem Statement**

Given a string `s`, determine if it is a **palindrome**,
**considering only alphanumeric characters** and **ignoring cases**.

---

### **Examples**

| Input                              | Output  | Explanation                                       |
| ---------------------------------- | ------- | ------------------------------------------------- |
| `"A man, a plan, a canal: Panama"` | ✅ True  | Ignore symbols & case → `"amanaplanacanalpanama"` |
| `"race a car"`                     | ❌ False | → `"raceacar"` ≠ reverse                          |
| `" "`                              | ✅ True  | Empty after cleaning                              |
| `"No lemon, no melon"`             | ✅ True  | Palindrome ignoring punctuation                   |

---

### **Hinglish Understanding**

String diya hai,

* **Letters aur digits** ke alawa sab ignore karne hain (spaces, commas, etc.)
* Compare karna hai **case-insensitive** (A == a).
* Agar clean hone ke baad palindrome bache → true, warna false.

Example:

```
"A man, a plan, a canal: Panama"
→ "amanaplanacanalpanama"
→ reverse same → palindrome ✅
```

---

## **2. Concept Breakdown**

To check palindrome normally, we compare from both ends:

```
s[l] == s[r]
```

Here we just add **2 filters**:

1. Ignore non-alphanumeric characters.
2. Compare in lowercase form.

---

### **Alphanumeric means:**

* All English letters (A-Z, a-z)
* All digits (0–9)

---

## **3. Approach — Two Pointer with Filtering (Optimal O(n))**

### **Algorithm**

1. Initialize two pointers: `l = 0`, `r = s.length() - 1`
2. While `l < r`:

   * If `s[l]` not alphanumeric → move `l++`
   * Else if `s[r]` not alphanumeric → move `r--`
   * Else:

     * Compare `tolower(s[l])` and `tolower(s[r])`
     * If not equal → return false
     * Else move inward → `l++, r--`
3. Return true after loop.

---

### **Code (C++)**

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isPalindrome(string s) {
    int l = 0, r = s.size() - 1;

    while (l < r) {
        // Skip non-alphanumeric characters
        if (!isalnum(s[l])) { l++; continue; }
        if (!isalnum(s[r])) { r--; continue; }

        // Compare lowercased characters
        if (tolower(s[l]) != tolower(s[r])) return false;

        l++;
        r--;
    }
    return true;
}

int main() {
    string s = "A man, a plan, a canal: Panama";
    cout << (isPalindrome(s) ? "Palindrome" : "Not Palindrome");
}
```

---

### **Dry Run**

Input: `"A man, a plan, a canal: Panama"`

| Step | l           | r   | s[l]    | s[r] | Comparison | Action    |
| ---- | ----------- | --- | ------- | ---- | ---------- | --------- |
| 0    | 0           | 29  | A       | a    | A=a ✅      | move both |
| 1    | 1           | 28  | (space) | m    | skip left  |           |
| 2    | 2           | 28  | m       | m    | ✅          | move both |
| ...  | ...         | ... | ...     | ...  | ...        | ...       |
| end  | all matched |     | ✅       |      |            |           |

Output → `"Palindrome"`

---

### **Hinglish Explanation**

* Do pointer se dono ends se check kiya.
* Non-alphanumeric characters (space, comma, colon) skip kiye.
* Compare lowercase me kiya (`A` aur `a` same).
* Agar sab match ho gaye → palindrome hai.
* Kisi step par mismatch mila → palindrome nahi.

---

## **4. Alternative Approach — Preprocessing + Reverse Compare**

### **Idea**

1. Remove all non-alphanumeric chars.
2. Convert to lowercase.
3. Check if cleaned string == reverse(cleaned).

---

### **Code (C++)**

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isPalindrome(string s) {
    string clean = "";
    for (char c : s) {
        if (isalnum(c)) clean += tolower(c);
    }
    string rev = clean;
    reverse(rev.begin(), rev.end());
    return clean == rev;
}

int main() {
    string s = "race a car";
    cout << (isPalindrome(s) ? "Palindrome" : "Not Palindrome");
}
```

---

### **Dry Run**

`s = "race a car"`

| Step           | Cleaned      | Reverse | Equal? |
| -------------- | ------------ | ------- | ------ |
| → `"raceacar"` | `"racacear"` | ❌       |        |

Output → `Not Palindrome`

---

### **Hinglish Explanation**

* String me se sirf valid chars liye (`isalnum`).
* Lowercase me convert kiya.
* Reverse karke compare kiya.
* Agar equal → palindrome ✅.
* Simple but uses O(n) extra space.

---

## **5. Comparison of Approaches**

| Approach             | Time | Space | Notes                         |
| -------------------- | ---- | ----- | ----------------------------- |
| Two-pointer          | O(n) | O(1)  | In-place, best for interviews |
| Preprocess + Reverse | O(n) | O(n)  | Easy to understand            |

---

## **6. Edge Cases**

| Input   | Output | Reason                 |
| ------- | ------ | ---------------------- |
| `" "`   | ✅      | Empty after cleaning   |
| `"0P"`  | ❌      | 0 ≠ p                  |
| `"a."`  | ✅      | After cleaning → `"a"` |
| `"1a1"` | ✅      | numeric + char same    |

---

## **7. Summary Table**

| Concept           | Explanation                                   |
| ----------------- | --------------------------------------------- |
| Valid palindrome  | Ignore non-alphanumeric + case-insensitive    |
| Two-pointer logic | Compare ends, skip invalid chars              |
| Key functions     | `isalnum()`, `tolower()`                      |
| Best method       | Two-pointer O(n), O(1)                        |
| Common pitfalls   | Forgetting to skip punctuation or handle case |

---

## **8. Recap**

* Palindrome check karte hue,
  **sirf letters aur digits** consider karte hain.
* **Non-alphanumeric skip karo** aur **case ignore karo**.
* **Two-pointer approach** sabse fast hai (O(n)).
* Interview me bola jaata hai:
  “We can solve this in one pass without extra space using two-pointer technique.”

---
