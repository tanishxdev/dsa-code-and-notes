# STRING SERIES

## Topic: Reverse a String (3 Approaches — Iterative, Recursive, In-place)

---

## **1. Problem Statement**

Given a string `s`, reverse it **in-place** or **return a new reversed string**.
We must understand and implement all three approaches — **Iterative**, **Recursive**, and **In-place**.

---

### **Example**

| Input      | Output     |
| ---------- | ---------- |
| `"hello"`  | `"olleh"`  |
| `"Tanish"` | `"hsinaT"` |
| `"a"`      | `"a"`      |
| `""`       | `""`       |

---

### **Hinglish Understanding**

Ek string di gayi hai — usse **ulta** karna hai.
Matlab pehla character last mein, last character pehla ho jaaye.

Example:

```
Input: "abcde"
Output: "edcba"
```

---

## **2. Concept Breakdown**

### What does “Reverse” actually mean?

If `s = "abcd"`,
then we want to rearrange characters as:

| Original | Index | Reversed | New Index |
| -------- | ----- | -------- | --------- |
| 'a'      | 0     | 'd'      | 3         |
| 'b'      | 1     | 'c'      | 2         |
| 'c'      | 2     | 'b'      | 1         |
| 'd'      | 3     | 'a'      | 0         |

---

So, `reverse(s)` basically = swap characters symmetrically from both ends.
That’s the **key intuition**.

---

## **3. Approach 1 — Iterative (Using Extra String)**

### **Thought Process**

* We can **traverse string from the end** and **build a new reversed string**.
* Simple and intuitive — but uses extra space.

---

### **Algorithm**

1. Initialize an empty string `rev`.
2. Loop `i` from `n-1` down to `0`.
3. Append `s[i]` to `rev`.
4. Return `rev`.

---

### **Code (C++)**

```cpp
#include <bits/stdc++.h>
using namespace std;

string reverseIterative(string s) {
    string rev = "";             // Step 1: empty string
    for (int i = s.length() - 1; i >= 0; i--) {
        rev += s[i];             // Step 2: append last to first
    }
    return rev;                  // Step 3: return reversed
}

int main() {
    string s = "hello";
    cout << reverseIterative(s); // Output: olleh
}
```

---

### **Dry Run**

| i | s[i] | rev (after append) |
| - | ---- | ------------------ |
| 4 | o    | "o"                |
| 3 | l    | "ol"               |
| 2 | l    | "oll"              |
| 1 | e    | "olle"             |
| 0 | h    | "olleh"            |

---

### **Hinglish Explanation**

* Humne end se start tak travel kiya.
* Har character ek naye string ke end me joda.
* Simple but space lagta hai `O(n)`.

---

### **Time & Space Complexity**

| Complexity | Value | Explanation                   |
| ---------- | ----- | ----------------------------- |
| Time       | O(n)  | Traverses each character once |
| Space      | O(n)  | New string created            |

---

## **4. Approach 2 — Recursive**

### **Thought Process**

Recursion means breaking big problem into smaller same problems.

> “Reverse of string = last character + reverse of remaining substring.”

Mathematically:

```
reverse("abc") = reverse("bc") + "a"
```

---

### **Algorithm**

1. Base Case → if string is empty or 1 char → return as is.
2. Recursive Step → `return reverse(s.substr(1)) + s[0];`

---

### **Code (C++)**

```cpp
#include <bits/stdc++.h>
using namespace std;

string reverseRecursive(string s) {
    // Base condition: single char or empty string
    if (s.length() <= 1) return s;

    // Recursive relation:
    return reverseRecursive(s.substr(1)) + s[0];
}

int main() {
    string s = "abcd";
    cout << reverseRecursive(s); // Output: dcba
}
```

---

### **Dry Run (for “abc”)**

| Function Call  | Return Value            |
| -------------- | ----------------------- |
| reverse("abc") | reverse("bc") + 'a'     |
| reverse("bc")  | reverse("c") + 'b'      |
| reverse("c")   | "c"                     |
| Combine        | "c" + "b" + "a" = "cba" |

---

### **Hinglish Explanation**

Recursion ne har call me ek character chhoda aur baaki ko reverse kar diya.
Phir end me first character ko append kar diya.
Simple but thoda **space heavy** hota hai (recursive stack lagta hai).

---

### **Time & Space Complexity**

| Complexity | Value | Explanation                                 |
| ---------- | ----- | ------------------------------------------- |
| Time       | O(n²) | Because `substr()` copies string every time |
| Space      | O(n)  | Recursive call stack                        |

> Note: Using indices instead of `substr()` can make it O(n).

---

## **5. Approach 3 — In-place (Two Pointer / Swap)**

### **Thought Process**

We can reverse the string **without extra space** by swapping characters from both ends.

**Idea:**

* Start pointer `l = 0`, end pointer `r = n-1`
* Swap `s[l]` and `s[r]`
* Move inward → `l++`, `r--`
* Stop when `l >= r`

---

### **Algorithm**

1. Take two pointers `l = 0`, `r = n-1`.
2. While `l < r`:

   * Swap `s[l]` and `s[r]`
   * Increment `l`, decrement `r`.
3. Return string.

---

### **Code (C++)**

```cpp
#include <bits/stdc++.h>
using namespace std;

void reverseInPlace(string &s) {
    int l = 0, r = s.length() - 1;
    while (l < r) {
        swap(s[l], s[r]); // swap both ends
        l++;
        r--;
    }
}

int main() {
    string s = "Tanish";
    reverseInPlace(s);
    cout << s; // Output: hsinaT
}
```

---

### **Dry Run**

| Step | l | r | Before Swap | After Swap |
| ---- | - | - | ----------- | ---------- |
| 1    | 0 | 5 | Tanish      | hsaniT     |
| 2    | 1 | 4 | hsaniT      | hsinaT     |
| Stop | 2 | 3 | —           | —          |

Result = `"hsinaT"`

---

### **Hinglish Explanation**

* Do pointer le liye — ek start, ek end.
* Dono ke character swap karte chale gaye.
* Jab tak cross nahi karte, tab tak loop chalta.
* Extra string nahi banaya → in-place ho gaya.

---

### **Time & Space Complexity**

| Complexity | Value | Explanation                  |
| ---------- | ----- | ---------------------------- |
| Time       | O(n)  | Every character swapped once |
| Space      | O(1)  | Only a few variables used    |

---

## **6. Comparison of All 3 Approaches**

| Approach  | Time  | Space | Key Idea            | Notes                |
| --------- | ----- | ----- | ------------------- | -------------------- |
| Iterative | O(n)  | O(n)  | Build new string    | Easy but extra space |
| Recursive | O(n²) | O(n)  | Divide and combine  | Elegant but slower   |
| In-place  | O(n)  | O(1)  | Swap from both ends | Best for interviews  |

---

## **7. Interview Notes**

* **Most Expected:** In-place two pointer version.
* **Common Follow-ups:**

  * Reverse words in a sentence (next topic).
  * Check if string is palindrome.
  * Reverse substring from index i to j.

---

## **8. Related Practice Problems**

| Problem                 | Platform     | Type   |
| ----------------------- | ------------ | ------ |
| Reverse String          | LeetCode 344 | Easy   |
| Reverse String II       | LeetCode 541 | Medium |
| Reverse Words in String | LeetCode 151 | Medium |
| Palindrome String       | GFG          | Easy   |

---

## **9. Summary**

| Concept             | Summary                            |
| ------------------- | ---------------------------------- |
| Iterative           | Traverse from end → build reversed |
| Recursive           | Use call stack → combine reversed  |
| In-place            | Swap two ends → in O(1) space      |
| Key Pattern         | `while (l < r) swap(l, r)`         |
| Best for Interviews | In-place two pointer               |
| Common Extension    | Reverse words, Palindrome          |

---

## **10. Recap**

* String reverse karne ke 3 tareeke:

  1. **Iterative** – end se characters lekar new string banai.
  2. **Recursive** – har call me first char end me joda.
  3. **In-place** – do pointer se swap karte gaye.

* Interview ke liye **in-place** method sabse efficient hai (O(n), O(1)).
