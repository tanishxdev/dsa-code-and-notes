# STRING SERIES

## Topic: Check if Two Strings are Anagrams

*(Sorting | Frequency Count | Hash Map approaches)*

---

## **1. Problem Statement**

Given two strings `s1` and `s2`, check whether they are **anagrams** of each other.

> **Definition:**
> Two strings are *anagrams* if they contain **exactly the same characters** with **the same frequency**, regardless of order.

---

### **Examples**

| Input                      | Output  | Explanation             |
| -------------------------- | ------- | ----------------------- |
| `"listen"`, `"silent"`     | ✅ True  | Same letters rearranged |
| `"triangle"`, `"integral"` | ✅ True  | Same characters         |
| `"apple"`, `"pale"`        | ❌ False | Frequency mismatch      |
| `"aab"`, `"aba"`           | ✅ True  | Same letters            |
| `"rat"`, `"car"`           | ❌ False | Different letters       |

---

### **Hinglish Explanation**

Do strings diye gaye hain.
Check karna hai ki kya dono **same letters se bane hain**, bas order alag ho sakta hai.
Matlab `"listen"` aur `"silent"` same letters se bane hain → **anagrams**.

---

## **2. Concept Breakdown**

### **How to Think**

For two strings to be anagrams:

1. Length must be **same**.
2. Every character should appear **equal number of times** in both.

So we just need to **compare frequencies**.

---

## **3. Approach 1 — Sorting Based**

### **Thought Process**

If we sort both strings alphabetically,
then both anagrams will become **identical**.

Example:

```
s1 = "listen" → "eilnst"
s2 = "silent" → "eilnst"
```

→ Same after sorting → anagram ✅

---

### **Algorithm**

1. If lengths differ → return false.
2. Sort both strings.
3. Compare if `s1 == s2`.

---

### **Code (C++)**

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isAnagramSort(string s1, string s2) {
    if (s1.length() != s2.length()) return false;
    sort(s1.begin(), s1.end());
    sort(s2.begin(), s2.end());
    return (s1 == s2);
}

int main() {
    string s1 = "listen", s2 = "silent";
    cout << (isAnagramSort(s1, s2) ? "Anagram" : "Not Anagram");
}
```

---

### **Dry Run**

| Step | s1         | s2         | Equal? |
| ---- | ---------- | ---------- | ------ |
| Sort | `"eilnst"` | `"eilnst"` | ✅ True |

Output → `"Anagram"`

---

### **Hinglish Explanation**

* Dono strings ko sort kiya.
* Agar dono same aa gaye → dono me same characters → anagram.
* Easy but sorting O(n log n) time lagata hai.

---

### **Time & Space Complexity**

| Complexity | Value                            |
| ---------- | -------------------------------- |
| Time       | O(n log n)                       |
| Space      | O(1) or O(n) (depending on sort) |

---

## **4. Approach 2 — Frequency Count (Optimal O(n))**

### **Thought Process**

Instead of sorting,
we can count frequency of each character and compare counts.

---

### **Algorithm (for lowercase English letters)**

1. If lengths differ → false.
2. Create frequency array of size 26.
3. For each char in `s1`, increment freq.
4. For each char in `s2`, decrement freq.
5. If all zeros → anagram.

---

### **Code (C++)**

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isAnagramFreq(string s1, string s2) {
    if (s1.length() != s2.length()) return false;

    vector<int> freq(26, 0);  // for a-z

    // Increment for s1
    for (char c : s1) {
        freq[c - 'a']++;
    }

    // Decrement for s2
    for (char c : s2) {
        freq[c - 'a']--;
    }

    // Check all zeros
    for (int i : freq) {
        if (i != 0) return false;
    }

    return true;
}

int main() {
    string s1 = "aab", s2 = "aba";
    cout << (isAnagramFreq(s1, s2) ? "Anagram" : "Not Anagram");
}
```

---

### **Dry Run**

Input: `"aab"`, `"aba"`

| Step  | Char     | freq[] change |
| ----- | -------- | ------------- |
| `aab` | +a,+a,+b | `[2,1,0,...]` |
| `aba` | -a,-b,-a | `[0,0,0,...]` |

All zeros → ✅ Anagram.

---

### **Hinglish Explanation**

* Pehle string ke characters ka count badhaya.
* Dusre string ke characters ka count ghata diya.
* Agar sab zero bache → dono me same chars same frequency → anagram.
* Ye sabse **fast** method hai.

---

### **Time & Space Complexity**

| Complexity | Value | Reason                |
| ---------- | ----- | --------------------- |
| Time       | O(n)  | Single traversal      |
| Space      | O(1)  | Fixed 26-length array |

---

## **5. Approach 3 — Using Hash Map (for all characters)**

If string may contain **uppercase, digits, symbols**,
then we need a map instead of fixed array.

---

### **Code (C++)**

```cpp
#include <bits/stdc++.h>
using namespace std;

bool isAnagramMap(string s1, string s2) {
    if (s1.length() != s2.length()) return false;

    unordered_map<char, int> mp;

    // Count frequency from s1
    for (char c : s1) mp[c]++;

    // Decrease from s2
    for (char c : s2) {
        mp[c]--;
        if (mp[c] < 0) return false; // early exit
    }

    return true;
}

int main() {
    string s1 = "Listen", s2 = "Silent";
    // Case-insensitive
    transform(s1.begin(), s1.end(), s1.begin(), ::tolower);
    transform(s2.begin(), s2.end(), s2.begin(), ::tolower);
    cout << (isAnagramMap(s1, s2) ? "Anagram" : "Not Anagram");
}
```

---

### **Dry Run**

Input: `"Listen"`, `"Silent"`

| Step  | mp after s1             | mp after s2         |
| ----- | ----------------------- | ------------------- |
| Count | L:1,i:1,s:1,t:1,e:1,n:1 | each decreases to 0 |
| Final | All zero → ✅            |                     |

Output: `"Anagram"`

---

### **Hinglish Explanation**

* Har character ka count map me store kiya.
* Dusre string ke characters se count ghata diya.
* Agar koi negative hua → extra character → not anagram.
* Map se uppercase, spaces, symbols sab handle ho jate hain.

---

### **Time & Space Complexity**

| Complexity | Value               |
| ---------- | ------------------- |
| Time       | O(n)                |
| Space      | O(k) (unique chars) |

---

## **6. Case-Insensitive & Space-Ignoring Version**

Sometimes interviewer will say:

> “Ignore case and spaces.”

Then:

1. Convert both to lowercase.
2. Remove all spaces before comparison.

---

### **Code Snippet**

```cpp
string clean(string s) {
    string res = "";
    for (char c : s) {
        if (isalnum(c)) res += tolower(c);
    }
    return res;
}

bool isAnagramClean(string s1, string s2) {
    s1 = clean(s1);
    s2 = clean(s2);
    return isAnagramFreq(s1, s2);
}
```

---

### **Example**

`"Dormitory"` and `"Dirty Room!!"`
→ after cleaning both → `"dormitory"` & `"dirtyroom"`
→ ✅ anagram

---

## **7. Comparison of All Approaches**

| Approach        | Time       | Space | Handles             | Notes             |
| --------------- | ---------- | ----- | ------------------- | ----------------- |
| Sorting         | O(n log n) | O(1)  | Simple alphabets    | Beginner friendly |
| Frequency Array | O(n)       | O(1)  | Lowercase only      | Optimal           |
| Hash Map        | O(n)       | O(k)  | All characters      | Versatile         |
| Cleaned Version | O(n)       | O(1)  | Ignores case/spaces | Real-world usage  |

---

## **8. Edge Cases**

| s1             | s2             | Output | Reason                 |
| -------------- | -------------- | ------ | ---------------------- |
| `"a"`          | `"a"`          | ✅      | same char              |
| `"ab"`         | `"a"`          | ❌      | length mismatch        |
| `"aa"`         | `"ab"`         | ❌      | frequency mismatch     |
| `"Debit Card"` | `"Bad Credit"` | ✅      | ignoring case & spaces |

---

## **9. Interview Notes**

* Interviewers usually ask:

  * “How will you handle case differences?”
  * “What if characters include digits?”
  * “Can you do it in O(n)?”
* Always begin with sorting approach,
  then optimize to frequency count.
* For system-level strings (like Unicode), use maps not arrays.

---

## **10. Hinglish Recap**

* **Anagram** = same letters + same count + different order.
* **3 methods:**

  1. **Sorting:** Easy but O(n log n).
  2. **Frequency array:** Fastest for lowercase.
  3. **Hash map:** Flexible for all characters.
* Interview me pucho to bolo:

  > “I’ll first check length, then frequency of each character in O(n) using a fixed-size array.”

---
