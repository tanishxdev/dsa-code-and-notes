## 26. Remove Duplicates from Sorted Array

Problem Link https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/


Given a sorted array of integers, remove duplicates in-place and return the number of unique elements. The first `k` elements of the array should contain the unique elements in sorted order.

**Breakdown**:

- **Input**: Sorted array `arr` of size `n` with integers.
- **Output**: Integer `k` (number of unique elements), with `arr[0..k-1]` containing unique elements in sorted order.
- **What We Need to Do**: Modify the array in-place to keep unique elements at the start, return count of unique elements.
- **Why is This a Problem?**: Tests in-place manipulation and handling duplicates.
- **Key Point**: Array is sorted, so duplicates are adjacent.

**Constraints**:

- `0 <= n <= 3 * 10^4`
- `100 <= arr[i] <= 100`

**Examples**:

- Input: `arr = [1, 1, 2, 2, 2, 3, 3]`
Output: `3`, `arr = [1, 2, 3, _, _, _, _]`
Explanation: Unique elements are `1, 2, 3`, `k=3`.
- Input: `arr = [1, 1, 1]`
Output: `1`, `arr = [1, _, _]`
- Input: `arr = []`
Output: `0`

**Key Definitions**:

- **In-place**: Modify the array without using extra space.
- **Unique Elements**: Elements without duplicates, in sorted order.
- **Hinglish**: Sorted array se duplicates hatao, unique elements starting mein daal do, aur count return karo.

**Prerequisite**:

- Array traversal, two-pointer technique.

**Key Observation**:

- Since the array is sorted, duplicates are adjacent, making it easier to identify unique elements.
- A two-pointer approach can efficiently place unique elements at the start.

### ðŸ”´ Approach 1: Brute Force (Using Set)

**Thought Process**:

- *Whatâ€™s the goal?* Remove duplicates and return count of unique elements.
- *How to model?* Use a set to store unique elements, then copy them back to the array.
- *Choices?* Set automatically handles duplicates due to sorting.
- *Hinglish*: Set mein unique elements daal do, phir array ke start mein copy karo.

**Examples to Prove Idea**:

- `arr = [1, 1, 2, 2, 2, 3, 3]`:
    - Set: `{1, 2, 3}`.
    - Copy to array: `arr = [1, 2, 3, _, _, _, _]`.
    - Return: `3`.
- *Why it works*: Set stores unique elements in sorted order, copy ensures in-place result.

**Intuition**:

Insert all elements into a set (which keeps unique elements in sorted order). Copy set elements to the start of the array. Return the set size.

**Dry Run**:

- Input: `arr = [1, 1, 2, 2, 2, 3, 3]`.
- Initialize: `s = {}` (set).
- Steps:
    - Insert `1` â†’ `s = {1}`.
    - Insert `1` (skip, duplicate).
    - Insert `2` â†’ `s = {1, 2}`.
    - Insert `2` (skip).
    - Insert `2` (skip).
    - Insert `3` â†’ `s = {1, 2, 3}`.
    - Insert `3` (skip).
- Copy to array: `arr[0] = 1`, `arr[1] = 2`, `arr[2] = 3`.
- Return: `3`.
- *Hinglish*: Set mein unique elements daale, phir array mein copy kiya, 3 return kiya.

**Algorithm**:

1. Initialize empty `set<int> s`.
2. For `i` from `0` to `n-1`:
    - Insert `arr[i]` into `s`.
3. Initialize `index = 0`.
4. For each element `x` in `s`:
    - Set `arr[index] = x`.
    - Increment `index`.
5. Return `index`.

**Pseudocode**:

```cpp
function removeDuplicatesBrute(arr, n):
    s = empty set
    for i from 0 to n-1:
        s.insert(arr[i])
    index = 0
    for x in s:
        arr[index] = x
        index += 1
    return index

```

**Code**:

```cpp
int removeDuplicatesBrute(vector<int>& arr) {
    int n = arr.size();
    set<int> s;
    for (int i = 0; i < n; i++) {
        s.insert(arr[i]);
    }
    int index = 0;
    for (int x : s) {
        arr[index++] = x;
    }
    return index;
}

```

**Time Complexity (TC)**:

- Set insertion: `O(n log n)` (logarithmic per insertion).
- Copying to array: `O(n)`.
- Total: `O(n log n)`.
- Why? Set operations dominate.

**Space Complexity (SC)**:

- `O(n)` (set stores up to `n` elements).
- Why? Extra space for set.

**Notes/Observations**:

- *Why brute?* Simple but uses extra space and is slower.
- *Hinglish*: Set se unique elements liye, par space aur time zyada laga.
- *Limitation*: `O(n log n)` time and `O(n)` space are inefficient.

### ðŸŸ¢ Approach 2: Optimal (Two Pointers)

**Thought Process**:

- *Can we improve?* Use the sorted property to compare adjacent elements in-place.
- *How?* Keep a pointer `i` for the next unique elementâ€™s position, traverse with `j` to find non-duplicate elements, and place them at `i+1`.
- *Hinglish*: Do pointer rakho, ek unique elements ke liye, doosra agla unique dhoondhne ke liye, in-place daal do.

**Examples to Prove Idea**:

- `arr = [1, 1, 2, 2, 2, 3, 3]`:
    - `i=0` (at `1`), `j=1`: `arr[1] = 1` (skip, same as `arr[0]`).
    - `j=2`: `arr[2] = 2 != 1`, place `2` at `i+1=1`, `i=1`.
    - `j=3`: `arr[3] = 2` (skip).
    - `j=4`: `arr[4] = 2` (skip).
    - `j=5`: `arr[5] = 3 != 2`, place `3` at `i+1=2`, `i=2`.
    - `j=6`: `arr[6] = 3` (skip).
    - Array: `[1, 2, 3, _, _, _, _]`, return `i+1 = 3`.
- *Why it works*: Adjacent duplicates are skipped, unique elements are placed in order.

**Intuition**:

Use two pointers: `i` (position for next unique element) and `j` (scans for next unique element). If `arr[j] != arr[i]`, place `arr[j]` at `i+1` and increment `i`. Return `i+1` as the count of unique elements.

**Dry Run**:

- Input: `arr = [1, 1, 2, 2, 2, 3, 3]`.
- Initialize: `i = 0` (at `1`).
- Steps:
    - `j=1`: `arr[1] = 1 == arr[0]`, skip.
    - `j=2`: `arr[2] = 2 != arr[0]`, `arr[1] = 2`, `i=1`.
    - `j=3`: `arr[3] = 2 == arr[1]`, skip.
    - `j=4`: `arr[4] = 2 == arr[1]`, skip.
    - `j=5`: `arr[5] = 3 != arr[1]`, `arr[2] = 3`, `i=2`.
    - `j=6`: `arr[6] = 3 == arr[2]`, skip.
- Array: `[1, 2, 3, _, _, _, _]`.
- Return: `i+1 = 3`.
- *Hinglish*: Do pointer se unique elements starting mein daale, 3 unique mile.

**Algorithm**:

1. If `n <= 1`, return `n`.
2. Initialize `i = 0`.
3. For `j` from `1` to `n-1`:
    - If `arr[j] != arr[i]`, increment `i`, set `arr[i] = arr[j]`.
4. Return `i + 1`.

**Pseudocode**:

```cpp
function removeDuplicatesOptimal(arr, n):
    if n <= 1:
        return n
    i = 0
    for j from 1 to n-1:
        if arr[j] != arr[i]:
            i += 1
            arr[i] = arr[j]
    return i + 1

```

**Code**:

```cpp
int removeDuplicatesOptimal(vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return n;
    int i = 0;
    for (int j = 1; j < n; j++) {
        if (arr[j] != arr[i]) {
            i++;
            arr[i] = arr[j];
        }
    }
    return i + 1;
}

```

**Time Complexity (TC)**:

- Single loop: `O(n)`.
- Total: `O(n)`.
- Why? One pass through the array.

**Space Complexity (SC)**:

- `O(1)` (in-place).
- Why? Only two pointers used.

**Notes/Observations**:

- *Why optimal?* Achieves `O(n)` time with `O(1)` space, leveraging sorted property.
- *Hinglish*: Two pointers se unique elements daale, time aur space bacha.
- *Edge Cases*:
    - Empty array: Return `0`.
    - Single element: Return `1`.
    - All duplicates: Return `1`.