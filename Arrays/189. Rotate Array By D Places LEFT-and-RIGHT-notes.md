
## Problem: Rotate Array (Left and Right Rotations)

https://www.geeksforgeeks.org/problems/rotate-array-by-n-elements-1587115621/1

**Problem Statement**:

Given an array of `n` integers and a number `d`, perform a **left rotation** or **right rotation** by `d` positions in-place. The array may contain duplicates, and the rotation is cyclic (elements wrap around). Left rotation moves the first `d` elements to the end, while right rotation moves the last `d` elements to the start.

**Breakdown**:

- **Input**: Array of integers `arr` and number of rotations `d`.
- **Output**: Array rotated in-place (left or right by `d` positions).
- **What We Need to Do**: Shift elements cyclically by `d` positions, either left or right, modifying the array in-place.
- **Why is This a Problem?** Requires efficient handling of cyclic shifts, especially without extra space, while managing large `d` values and duplicates.
- **Hinglish**: Array diya hai, `d` positions left ya right rotate karna hai, in-place, duplicates ho sakte hain, `d` bada bhi ho sakta hai.

**Constraints**:

- `1 â‰¤ arr.size() â‰¤ 10^5`
- `10^9 â‰¤ arr[i] â‰¤ 10^9`
- `0 â‰¤ d â‰¤ 10^9`

**Examples**:

- **Example 1 (Left Rotation)**:
    - Input: `arr = [1,2,3,4,5,6,7], d = 3`
    - Output: `[4,5,6,7,1,2,3]`
    - Explanation: First 3 elements move to end.
- **Example 2 (Right Rotation)**:
    - Input: `arr = [1,2,3,4,5,6,7], d = 3`
    - Output: `[5,6,7,1,2,3,4]`
    - Explanation: Last 3 elements move to start.
- **Example 3 (Edge Case)**:
    - Input: `arr = [1,2], d = 3`
    - Output (Left): `[2,1]` (since `d = 3 % 2 = 1`)
    - Output (Right): `[2,1]`
    - Explanation: `d` is taken modulo `n` for cyclic rotation.

**Key Definitions**:

- **Left Rotation**: Shift each element `d` positions left, with first `d` elements wrapping to end.
- **Right Rotation**: Shift each element `d` positions right, with last `d` elements wrapping to start.
- **Cyclic Rotation**: Elements wrap around the array boundaries.
- **Hinglish**: Left rotation: Pehle `d` elements end mein, baaki left shift. Right rotation: Last `d` elements start mein, baaki right shift.

**Prerequisites**:

- Understanding of array manipulation.
- Familiarity with in-place algorithms and reversal techniques.

**Problem Links**:

- [LeetCode 189: Rotate Array](https://leetcode.com/problems/rotate-array/)
- [GeeksforGeeks: Cyclically Rotate an Array](https://www.geeksforgeeks.org/cyclically-rotate-an-array-by-one/)

---

### Approaches for Rotate Array (Left and Right)

### ðŸ”´ Approach 1: Brute Force (Extra Array)

**Thought Process**:

- **Goal**: Rotate array left or right by `d` positions, handling duplicates and large `d`.
- **How?** For left rotation, save first `d` elements in a temp array, shift remaining elements left, place temp at end. For right rotation, save last `d` elements, shift remaining right, place temp at start.
- **Benefit?** Simple to understand, works for both directions.
- **Drawback?** Uses extra space for temp array.
- **Hinglish**: Left ke liye pehle `d` temp mein, baaki left shift, temp end mein. Right ke liye last `d` temp mein, baaki right shift, temp start mein.

**Examples to Prove Idea**:

- **Left Rotation**: `arr = [1,2,3,4,5,6,7], d = 3`
    - Save: `[1,2,3]`
    - Shift: `[4,5,6,7,*,*,*]`
    - Place: `[4,5,6,7,1,2,3]`
- **Right Rotation**: `arr = [1,2,3,4,5,6,7], d = 3`
    - Save: `[5,6,7]`
    - Shift: `[*,*,*,1,2,3,4]`
    - Place: `[5,6,7,1,2,3,4]`

**Intuition**:
Break rotation into saving a block, shifting the rest, and repositioning the saved block.

**Dry Run (Left Rotation)**:

- Input: `arr = [1,2,3,4,5,6,7], d = 3`
- Step 1: `d = 3 % 7 = 3`, `temp = [1,2,3]`
- Step 2: Shift `i=3` to `n-1`: `arr = [4,5,6,7,5,6,7]`
- Step 3: Place temp at `n-d=4`: `arr = [4,5,6,7,1,2,3]`
- Output: `[4,5,6,7,1,2,3]`
- **Hinglish**: Pehle 3 temp mein daale, baaki left shift, temp end mein daala.

**Dry Run (Right Rotation)**:

- Input: `arr = [1,2,3,4,5,6,7], d = 3`
- Step 1: `d = 3 % 7 = 3`, `temp = [5,6,7]`
- Step 2: Shift `i=3` to `0`: `arr = [*,*,*,1,2,3,4]`
- Step 3: Place temp at `0`: `arr = [5,6,7,1,2,3,4]`
- Output: `[5,6,7,1,2,3,4]`
- **Hinglish**: Last 3 temp mein, baaki right shift, temp start mein.

**Algorithm (Left Rotation)**:

1. Compute `d = d % n`.
2. If `d == 0`, return.
3. Store first `d` elements in temp array.
4. Shift elements from index `d` to `n-1` to position `i-d`.
5. Copy temp to indices `n-d` to `n-1`.

**Algorithm (Right Rotation)**:

1. Compute `d = d % n`.
2. If `d == 0`, return.
3. Store last `d` elements in temp array.
4. Shift elements from index `n-d-1` to `0` to position `i+d`.
5. Copy temp to indices `0` to `d-1`.

**Pseudocode (Left Rotation)**:

```cpp
function leftRotate(arr, d):
    n = arr.size
    d = d % n
    if d == 0: return
    temp = vector<int>(d)
    for i from 0 to d-1:
        temp[i] = arr[i]
    for i from d to n-1:
        arr[i-d] = arr[i]
    for i from 0 to d-1:
        arr[n-d+i] = temp[i]

```

**Pseudocode (Right Rotation)**:

```cpp
function rightRotate(arr, d):
    n = arr.size
    d = d % n
    if d == 0: return
    temp = vector<int>(d)
    for i from 0 to d-1:
        temp[i] = arr[n-d+i]
    for i from n-d-1 down to 0:
        arr[i+d] = arr[i]
    for i from 0 to d-1:
        arr[i] = temp[i]

```

**Code**:

```cpp
// ðŸ”´ Brute Force: Left Rotation
void leftRotate(vector<int>& arr, int d) {
    int n = arr.size();
    d = d % n; // Handle d > n
    if (d == 0) return;

    vector<int> temp(d); // Temp array for first d elements
    for (int i = 0; i < d; i++) {
        temp[i] = arr[i]; // Save first d elements
    }
    for (int i = d; i < n; i++) {
        arr[i - d] = arr[i]; // Shift remaining left
    }
    for (int i = 0; i < d; i++) {
        arr[n - d + i] = temp[i]; // Place temp at end
    }
}

// ðŸ”´ Brute Force: Right Rotation
void rightRotate(vector<int>& arr, int d) {
    int n = arr.size();
    d = d % n; // Handle d > n
    if (d == 0) return;

    vector<int> temp(d); // Temp array for last d elements
    for (int i = 0; i < d; i++) {
        temp[i] = arr[n - d + i]; // Save last d elements
    }
    for (int i = n - d - 1; i >= 0; i--) {
        arr[i + d] = arr[i]; // Shift remaining right
    }
    for (int i = 0; i < d; i++) {
        arr[i] = temp[i]; // Place temp at start
    }
}

```

**Time Complexity (TC)**:

- `O(n)`: Copy `d` elements to temp (O(d)), shift `n-d` elements (O(n-d)), copy `d` back (O(d)).
- **Why?** Total operations proportional to array size.

**Space Complexity (SC)**:

- `O(d)`: Temp array stores `d` elements.
- **Why?** Extra space only for `d` elements.

**Notes/Observations**:

- **Why Simple?** Intuitive save-shift-place logic.
- **Hinglish**: Temp mein block save, baaki shift, temp sahi jagah daal do.
- **Drawback**: Extra space O(d), not in-place.

---

### ðŸŸ¢ Approach 2: Reversal Algorithm (Optimal)

**Thought Process**:

- **Goal**: Rotate array in-place with minimal space.
- **How?** Use reversals to rearrange blocks. For left rotation: reverse first `d`, reverse rest, reverse all. For right rotation: reverse last `d`, reverse first `n-d`, reverse all.
- **Benefit?** In-place, O(1) space, elegant.
- **Hinglish**: Left ke liye pehle `d` reverse, baaki reverse, pura reverse. Right ke liye last `d` reverse, pehle `n-d` reverse, pura reverse.

**Examples to Prove Idea**:

- **Left Rotation**: `arr = [1,2,3,4,5,6,7], d = 3`
    - Reverse `[1,2,3]`: `[3,2,1,4,5,6,7]`
    - Reverse `[4,5,6,7]`: `[3,2,1,7,6,5,4]`
    - Reverse all: `[4,5,6,7,1,2,3]`
- **Right Rotation**: `arr = [1,2,3,4,5,6,7], d = 3`
    - Reverse `[5,6,7]`: `[1,2,3,4,7,6,5]`
    - Reverse `[1,2,3,4]`: `[4,3,2,1,7,6,5]`
    - Reverse all: `[5,6,7,1,2,3,4]`

**Intuition**:
Reversing parts swaps blocks, and final reversal aligns them correctly for rotation.

**Dry Run (Left Rotation)**:

- Input: `arr = [1,2,3,4,5,6,7], d = 3`
- Step 1: `d = 3 % 7 = 3`, reverse `[0,2]`: `[3,2,1,4,5,6,7]`
- Step 2: Reverse `[3,6]`: `[3,2,1,7,6,5,4]`
- Step 3: Reverse `[0,6]`: `[4,5,6,7,1,2,3]`
- Output: `[4,5,6,7,1,2,3]`
- **Hinglish**: Pehle 3 reverse, baaki reverse, pura reverse kiya.

**Dry Run (Right Rotation)**:

- Input: `arr = [1,2,3,4,5,6,7], d = 3`
- Step 1: `d = 3 % 7 = 3`, reverse `[4,6]`: `[1,2,3,4,7,6,5]`
- Step 2: Reverse `[0,3]`: `[4,3,2,1,7,6,5]`
- Step 3: Reverse `[0,6]`: `[5,6,7,1,2,3,4]`
- Output: `[5,6,7,1,2,3,4]`
- **Hinglish**: Last 3 reverse, pehle 4 reverse, pura reverse kiya.

**Algorithm (Left Rotation)**:

1. Compute `d = d % n`.
2. If `d == 0`, return.
3. Reverse indices `0` to `d-1`.
4. Reverse indices `d` to `n-1`.
5. Reverse indices `0` to `n-1`.

**Algorithm (Right Rotation)**:

1. Compute `d = d % n`.
2. If `d == 0`, return.
3. Reverse indices `n-d` to `n-1`.
4. Reverse indices `0` to `n-d-1`.
5. Reverse indices `0` to `n-1`.

**Pseudocode (Left Rotation)**:

```cpp
function leftRotate(arr, d):
    n = arr.size
    d = d % n
    if d == 0: return
    reverse(arr, 0, d-1)
    reverse(arr, d, n-1)
    reverse(arr, 0, n-1)

```

**Pseudocode (Right Rotation)**:

```cpp
function rightRotate(arr, d):
    n = arr.size
    d = d % n
    if d == 0: return
    reverse(arr, n-d, n-1)
    reverse(arr, 0, n-d-1)
    reverse(arr, 0, n-1)

```

**Code**:

```cpp
// ðŸ”µ Optimal: Reversal Algorithm - Left Rotation
void leftRotate(vector<int>& arr, int d) {
    int n = arr.size();
    d = d % n; // Handle d > n
    if (d == 0) return;

    reverse(arr.begin(), arr.begin() + d); // Reverse first d
    reverse(arr.begin() + d, arr.end()); // Reverse remaining
    reverse(arr.begin(), arr.end()); // Reverse all
}

// ðŸ”µ Optimal: Reversal Algorithm - Right Rotation
void rightRotate(vector<int>& arr, int d) {
    int n = arr.size();
    d = d % n; // Handle d > n
    if (d == 0) return;

    reverse(arr.begin() + (n - d), arr.end()); // Reverse last d
    reverse(arr.begin(), arr.begin() + (n - d)); // Reverse first n-d
    reverse(arr.begin(), arr.end()); // Reverse all
}

```

**Time Complexity (TC)**:

- `O(n)`: Three reversals: O(d) + O(n-d) + O(n) â‰ˆ O(n).
- **Why?** Total elements reversed is proportional to `n`.

**Space Complexity (SC)**:

- `O(1)`: In-place, no extra space except variables.
- **Why?** Reversals modify array directly.

**Notes/Observations**:

- **Why Optimal?** In-place, minimal space, elegant block swapping.
- **Hinglish**: Reverse trick se blocks swap, extra space nahi laga.
- **Key Insight**: Reversals rearrange blocks naturally for rotation.

---

### Final Consolidated Code

```cpp
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    // ðŸ”´ Brute Force: Left Rotation
    void leftRotateBrute(vector<int>& arr, int d) {
        int n = arr.size();
        d = d % n;
        if (d == 0) return;

        vector<int> temp(d);
        for (int i = 0; i < d; i++) {
            temp[i] = arr[i];
        }
        for (int i = d; i < n; i++) {
            arr[i - d] = arr[i];
        }
        for (int i = 0; i < d; i++) {
            arr[n - d + i] = temp[i];
        }
    }

    // ðŸ”´ Brute Force: Right Rotation
    void rightRotateBrute(vector<int>& arr, int d) {
        int n = arr.size();
        d = d % n;
        if (d == 0) return;

        vector<int> temp(d);
        for (int i = 0; i < d; i++) {
            temp[i] = arr[n - d + i];
        }
        for (int i = n - d - 1; i >= 0; i--) {
            arr[i + d] = arr[i];
        }
        for (int i = 0; i < d; i++) {
            arr[i] = temp[i];
        }
    }

    // ðŸ”µ Optimal: Reversal Algorithm - Left Rotation
    void leftRotate(vector<int>& arr, int d) {
        int n = arr.size();
        d = d % n;
        if (d == 0) return;

        reverse(arr.begin(), arr.begin() + d);
        reverse(arr.begin() + d, arr.end());
        reverse(arr.begin(), arr.end());
    }

    // ðŸ”µ Optimal: Reversal Algorithm - Right Rotation
    void rightRotate(vector<int>& arr, int d) {
        int n = arr.size();
        d = d % n;
        if (d == 0) return;

        reverse(arr.begin() + (n - d), arr.end());
        reverse(arr.begin(), arr.begin() + (n - d));
        reverse(arr.begin(), arr.end());
    }
};

int main() {
    vector<int> arr1 = {1, 2, 3, 4, 5, 6, 7};
    vector<int> arr2 = {1, 2, 3, 4, 5, 6, 7};
    vector<int> arr3 = {1, 2, 3, 4, 5, 6, 7};
    vector<int> arr4 = {1, 2, 3, 4, 5, 6, 7};
    int d = 3;
    Solution sol;

    // Test Left Rotation (Brute)
    cout << "Left Rotation (Brute Force):\\n";
    sol.leftRotateBrute(arr1, d);
    for (int x : arr1) cout << x << " "; // Expected: 4 5 6 7 1 2 3
    cout << endl;

    // Test Left Rotation (Reversal)
    cout << "Left Rotation (Reversal):\\n";
    sol.leftRotate(arr2, d);
    for (int x : arr2) cout << x << " "; // Expected: 4 5 6 7 1 2 3
    cout << endl;

    // Test Right Rotation (Brute)
    cout << "Right Rotation (Brute Force):\\n";
    sol.rightRotateBrute(arr3, d);
    for (int x : arr3) cout << x << " "; // Expected: 5 6 7 1 2 3 4
    cout << endl;

    // Test Right Rotation (Reversal)
    cout << "Right Rotation (Reversal):\\n";
    sol.rightRotate(arr4, d);
    for (int x : arr4) cout << x << " "; // Expected: 5 6 7 1 2 3 4
    cout << endl;

    return 0;
}

```

---

### Key Points for Interview

- **Brute Force**: `O(n)`, `O(d)` â€“ Simple save-shift-place, but uses extra space.
- **Reversal**: `O(n)`, `O(1)` â€“ Optimal, in-place, elegant block swapping.
- **Hinglish**: Interview mein brute se start, reversal se impress karo, `d % n` ka importance batao.
- **Edge Cases**:
    - `d = 0`: No rotation.
    - `d > n`: Use `d % n`.
    - Single element: `[1]` â†’ `[1]`.
    - Duplicates: Handled naturally.
- **Key Insight**: Reversal swaps blocks in-place, symmetric for left/right rotations.

---

### Additional Notes for Beginners

- **Why Rotation?** Teaches array manipulation and in-place techniques.
- **Hinglish**:
    - Brute: Temp mein block save, shift karo, temp daal do.
    - Reversal: Teen reverse se blocks rearrange, no extra space.
- **Practice**:
    - Left: `[1,2,3,4,5,6,7], d=3` â†’ `[4,5,6,7,1,2,3]`
    - Right: `[1,2,3,4,5,6,7], d=3` â†’ `[5,6,7,1,2,3,4]`
- **Related Problems**:
    - [LeetCode 189: Rotate Array](https://leetcode.com/problems/rotate-array/)
    - [GeeksforGeeks: Cyclically Rotate an Array](https://www.geeksforgeeks.org/cyclically-rotate-an-array-by-one/)
- **Interview Tip**: Draw array, show block movement for brute, explain reversal steps visually.

---