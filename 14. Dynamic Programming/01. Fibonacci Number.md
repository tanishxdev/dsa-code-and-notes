# PROBLEM (Original Statement)

The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1.

Given:  
F(0) = 0, F(1) = 1  
F(n) = F(n-1) + F(n-2), for n > 1.

Given n, calculate F(n).

---

## BREAKDOWN PROBLEM

We need to calculate the nth Fibonacci number using the definition:
- F(0) = 0 (base case)
- F(1) = 1 (base case)  
- For n > 1: F(n) = F(n-1) + F(n-2)

Input: Integer n (0 ≤ n ≤ 30 typically, but can be higher)
Output: Integer F(n)

---

## CONSTRAINT UNDERSTANDING

From the lecture and standard Fibonacci problem:
1. n can be 0 or positive integer
2. Recursive solution without memoization has exponential time complexity O(2^n)
3. With memoization: O(n) time, O(n) space
4. Optimal solution: O(n) time, O(1) space

---

# BRUTE FORCE APPROACH

## First Thought Intuition

The most natural approach is direct recursion: implement exactly what the definition says.

## Thought Process (Step-wise)

1. If n = 0, return 0
2. If n = 1, return 1  
3. Otherwise, return fib(n-1) + fib(n-2)

## Pseudocode

```
function fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)
```

## Algorithm

1. Check base cases (n = 0 or 1)
2. If not base case, recursively call fib(n-1) and fib(n-2)
3. Sum the results

## CODE (C++ and JavaScript)

### C++

#### V1 (Only Required Function as per Platform)

```cpp
class Solution {
public:
    int fib(int n) {
        if (n <= 1) {
            return n;
        }
        return fib(n - 1) + fib(n - 2);
    }
};
```

#### V2 (Complete Program)

```cpp
#include <iostream>
using namespace std;

// Recursive function to find nth Fibonacci number
int fib(int n) {
    // Base cases: F(0) = 0, F(1) = 1
    if (n <= 1) {
        return n;
    }
    
    // Recursive case: F(n) = F(n-1) + F(n-2)
    return fib(n - 1) + fib(n - 2);
}

int main() {
    // Test cases
    int test_cases[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    cout << "Fibonacci Numbers using Recursive Approach:" << endl;
    for (int i = 0; i < num_tests; i++) {
        int n = test_cases[i];
        int result = fib(n);
        cout << "F(" << n << ") = " << result << endl;
    }
    
    return 0;
}
```

### JavaScript

#### V1 (Only Required Function as per Platform)

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    if (n <= 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
};
```

#### V2 (Complete Program)

```javascript
// Recursive function to find nth Fibonacci number
function fib(n) {
    // Base cases: F(0) = 0, F(1) = 1
    if (n <= 1) {
        return n;
    }
    
    // Recursive case: F(n) = F(n-1) + F(n-2)
    return fib(n - 1) + fib(n - 2);
}

// Test cases
const testCases = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

console.log("Fibonacci Numbers using Recursive Approach:");
for (const n of testCases) {
    const result = fib(n);
    console.log(`F(${n}) = ${result}`);
}
```

## Time and Space Complexity

**Time Complexity:** O(2^n)  
- Each call creates 2 more calls (binary recursion tree)
- Total nodes ≈ 2^n

**Space Complexity:** O(n)  
- Maximum depth of recursion stack = n
- Each call uses constant space on stack

## Dry Run (All Cases)

**For n = 5:**
```
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
fib(3) = fib(2) + fib(1)
fib(2) = fib(1) + fib(0) = 1 + 0 = 1
fib(3) = 1 + 1 = 2
fib(4) = 2 + 1 = 3
fib(3) = fib(2) + fib(1) = 1 + 1 = 2 (recalculated!)
fib(5) = 3 + 2 = 5
```

## Edge Cases

1. **n = 0**: Returns 0 ✓
2. **n = 1**: Returns 1 ✓
3. **Large n (e.g., 30)**: Will be very slow due to exponential time

## How This Approach Handles the Problem

It directly implements the mathematical definition of Fibonacci numbers.

## Does This Approach Fail?

**YES**

**Where it fails:**
- For n > 30, takes too long (exponential time)
- Recalculates same subproblems many times (as shown in lecture tree diagram)

**Why it fails:**
- Exponential time complexity O(2^n)
- Repeating subproblems not stored
- Not efficient for practical use

---

# BETTER APPROACH (Memoization/Top-Down DP)

## First Thought Intuition

Store already computed results to avoid recalculating same subproblems (memoization).

## Thought Process (Step-wise)

1. Create array/dp to store computed Fibonacci values
2. Initialize with -1 (meaning not computed)
3. Before computing any fib(n), check if already computed
4. If computed, return stored value
5. If not computed, compute and store

## Pseudocode

```
function fib(n, memo):
    if n <= 1:
        return n
    
    if memo[n] != -1:
        return memo[n]
    
    memo[n] = fib(n-1, memo) + fib(n-2, memo)
    return memo[n]
```

## Algorithm

1. Create memoization array of size n+1, initialized to -1
2. Define recursive function with memo parameter
3. Check base cases
4. Check memo array before computation
5. Store result in memo array before returning

## CODE (C++ and JavaScript)

### C++

#### V1 (Only Required Function)

```cpp
class Solution {
public:
    int fib(int n) {
        // Create memoization array
        vector<int> memo(n + 1, -1);
        return solve(n, memo);
    }
    
private:
    int solve(int n, vector<int>& memo) {
        // Base cases
        if (n <= 1) {
            return n;
        }
        
        // If already computed, return from memo
        if (memo[n] != -1) {
            return memo[n];
        }
        
        // Compute and store in memo
        memo[n] = solve(n - 1, memo) + solve(n - 2, memo);
        return memo[n];
    }
};
```

#### V2 (Complete Program with main and tests)

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function with memoization
int solve(int n, vector<int>& memo) {
    // Base cases: F(0) = 0, F(1) = 1
    if (n <= 1) {
        return n;
    }
    
    // If result already computed, return from memo
    if (memo[n] != -1) {
        return memo[n];
    }
    
    // Compute result and store in memo
    memo[n] = solve(n - 1, memo) + solve(n - 2, memo);
    return memo[n];
}

// Main function to compute Fibonacci with memoization
int fib(int n) {
    // Create memoization array, initialize with -1
    vector<int> memo(n + 1, -1);
    return solve(n, memo);
}

int main() {
    // Test cases
    int test_cases[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30};
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    cout << "Fibonacci Numbers using Memoization (Top-Down DP):" << endl;
    for (int i = 0; i < num_tests; i++) {
        int n = test_cases[i];
        int result = fib(n);
        cout << "F(" << n << ") = " << result << endl;
    }
    
    return 0;
}
```

### JavaScript

#### V1 (Only Required Function)

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    // Create memoization array
    const memo = new Array(n + 1).fill(-1);
    
    function solve(k) {
        // Base cases
        if (k <= 1) {
            return k;
        }
        
        // If already computed, return from memo
        if (memo[k] !== -1) {
            return memo[k];
        }
        
        // Compute and store in memo
        memo[k] = solve(k - 1) + solve(k - 2);
        return memo[k];
    }
    
    return solve(n);
};
```

#### V2 (Complete Program with tests)

```javascript
// Function to compute Fibonacci with memoization
function fib(n) {
    // Create memoization array, initialize with -1
    const memo = new Array(n + 1).fill(-1);
    
    // Recursive helper function with memoization
    function solve(k) {
        // Base cases: F(0) = 0, F(1) = 1
        if (k <= 1) {
            return k;
        }
        
        // If result already computed, return from memo
        if (memo[k] !== -1) {
            return memo[k];
        }
        
        // Compute result and store in memo
        memo[k] = solve(k - 1) + solve(k - 2);
        return memo[k];
    }
    
    return solve(n);
}

// Test cases
const testCases = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30];

console.log("Fibonacci Numbers using Memoization (Top-Down DP):");
for (const n of testCases) {
    const result = fib(n);
    console.log(`F(${n}) = ${result}`);
}
```

## Time and Space Complexity

**Time Complexity:** O(n)
- Each subproblem computed only once
- n+1 unique states to compute

**Space Complexity:** O(n)
- Memoization array of size n+1
- Recursion stack depth O(n)

## Dry Run (All Cases)

**For n = 5:**
```
solve(5): memo[5] = -1 → compute
solve(4): memo[4] = -1 → compute
solve(3): memo[3] = -1 → compute
solve(2): memo[2] = -1 → compute
solve(1): return 1
solve(0): return 0
memo[2] = 1 + 0 = 1
memo[3] = memo[2] + solve(1) = 1 + 1 = 2
memo[4] = memo[3] + solve(2) = 2 + 1 = 3
memo[5] = memo[4] + solve(3) = 3 + 2 = 5
```

## Edge Cases

1. **n = 0**: Works fine, returns 0
2. **n = 1**: Works fine, returns 1
3. **Large n (e.g., 1000)**: Works but recursion depth might cause stack overflow

## How This Approach Handles the Problem

Stores computed results to avoid recomputation, converting exponential time to linear.

## Does This Approach Fail?

**NO** for correctness, but has **limitations**:
- Recursion depth limit for very large n
- Can cause stack overflow
- Extra overhead of recursion calls

This is acceptable but we can do better with bottom-up approach.

---

# OPTIMAL APPROACH (Bottom-Up DP / Space Optimized)

## First Thought Intuition

Instead of recursion, build solution iteratively from base cases. Since we only need last two values, use constant space.

## Thought Process (Step-wise)

1. Handle base cases (n = 0, 1)
2. Initialize prev2 = 0 (F(0)), prev1 = 1 (F(1))
3. For i from 2 to n:
   - current = prev1 + prev2
   - Update: prev2 = prev1, prev1 = current
4. Return prev1 (or current after loop)

## Pseudocode

```
function fib(n):
    if n <= 1:
        return n
    
    prev2 = 0  // F(0)
    prev1 = 1  // F(1)
    
    for i from 2 to n:
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1
```

## Algorithm

1. If n < 2, return n
2. Initialize two variables to store last two Fibonacci numbers
3. Iterate from 2 to n, computing next Fibonacci number
4. Update variables for next iteration
5. Return result

## CODE (C++ and JavaScript)

### C++

#### V1 (Only Required Function)

```cpp
class Solution {
public:
    int fib(int n) {
        // Base cases
        if (n <= 1) {
            return n;
        }
        
        // Initialize with F(0) and F(1)
        int prev2 = 0;  // F(0)
        int prev1 = 1;  // F(1)
        int current;
        
        // Build solution from bottom up
        for (int i = 2; i <= n; i++) {
            current = prev1 + prev2;  // F(i) = F(i-1) + F(i-2)
            prev2 = prev1;  // Update for next iteration
            prev1 = current;
        }
        
        return prev1;  // Or current, both same after loop
    }
};
```

#### V2 (Complete Program with main and tests)

```cpp
#include <iostream>
using namespace std;

// Optimized Fibonacci with O(1) space
int fib(int n) {
    // Base cases: F(0) = 0, F(1) = 1
    if (n <= 1) {
        return n;
    }
    
    // We only need to track last two Fibonacci numbers
    int prev2 = 0;  // Represents F(i-2)
    int prev1 = 1;  // Represents F(i-1)
    int current;
    
    // Iteratively build from 2 to n
    for (int i = 2; i <= n; i++) {
        // Current Fibonacci number
        current = prev1 + prev2;
        
        // Update for next iteration
        prev2 = prev1;
        prev1 = current;
    }
    
    return prev1;  // This holds F(n)
}

int main() {
    // Test cases
    int test_cases[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 40};
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    cout << "Fibonacci Numbers using Optimized Bottom-Up DP:" << endl;
    for (int i = 0; i < num_tests; i++) {
        int n = test_cases[i];
        int result = fib(n);
        cout << "F(" << n << ") = " << result << endl;
    }
    
    return 0;
}
```

### JavaScript

#### V1 (Only Required Function)

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var fib = function(n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    
    // Initialize with F(0) and F(1)
    let prev2 = 0;  // F(0)
    let prev1 = 1;  // F(1)
    let current;
    
    // Build solution iteratively
    for (let i = 2; i <= n; i++) {
        current = prev1 + prev2;  // F(i) = F(i-1) + F(i-2)
        prev2 = prev1;  // Update for next iteration
        prev1 = current;
    }
    
    return prev1;  // Or current, both same
};
```

#### V2 (Complete Program with tests)

```javascript
// Optimized Fibonacci with O(1) space
function fib(n) {
    // Base cases: F(0) = 0, F(1) = 1
    if (n <= 1) {
        return n;
    }
    
    // We only need to track last two Fibonacci numbers
    let prev2 = 0;  // Represents F(i-2)
    let prev1 = 1;  // Represents F(i-1)
    let current;
    
    // Iteratively build from 2 to n
    for (let i = 2; i <= n; i++) {
        // Current Fibonacci number
        current = prev1 + prev2;
        
        // Update for next iteration
        prev2 = prev1;
        prev1 = current;
    }
    
    return prev1;  // This holds F(n)
}

// Test cases
const testCases = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, 40];

console.log("Fibonacci Numbers using Optimized Bottom-Up DP:");
for (const n of testCases) {
    const result = fib(n);
    console.log(`F(${n}) = ${result}`);
}
```

## Time and Space Complexity

**Time Complexity:** O(n)
- Single loop from 2 to n
- Constant work per iteration

**Space Complexity:** O(1)
- Only 3 variables used (prev2, prev1, current)
- No extra arrays or recursion stack

## Dry Run (All Cases)

**For n = 5:**
```
n=5 (>1)
prev2=0, prev1=1
i=2: current=1+0=1, prev2=1, prev1=1
i=3: current=1+1=2, prev2=1, prev1=2
i=4: current=2+1=3, prev2=2, prev1=3
i=5: current=3+2=5, prev2=3, prev1=5
Return prev1=5 ✓
```

## Edge Cases

1. **n = 0**: Returns 0 (handled by base case)
2. **n = 1**: Returns 1 (handled by base case)
3. **n = 2**: Loop runs once, returns 1
4. **Very large n**: Works efficiently with O(n) time, O(1) space

## How This Approach Handles the Problem

Builds solution iteratively from base cases, using only last two values to compute next.

## Why This Is Optimal

1. **Time Complexity O(n)**: Must compute all n values sequentially
2. **Space Complexity O(1)**: Mathematical property: F(n) depends only on F(n-1) and F(n-2)
3. **No recursion overhead**: Avoids stack overflow risk
4. **Minimal memory usage**: Only 3 variables needed

This is optimal because:
- We must compute each Fibonacci number from 0 to n at least once → Ω(n) time
- We only need last two values to compute next → O(1) space possible
- No better asymptotic complexity exists for exact computation of Fibonacci numbers