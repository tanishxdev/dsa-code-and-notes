# PROBLEM (Original Statement)

You are climbing a staircase. It takes `n` steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Example 1:**  
Input: n = 2  
Output: 2  
Explanation: There are two ways to climb to the top:
1. 1 step + 1 step
2. 2 steps

**Example 2:**  
Input: n = 3  
Output: 3  
Explanation: There are three ways to climb to the top:
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

---

## BREAKDOWN PROBLEM

We need to find the number of distinct ways to climb a staircase with `n` steps, where we can take either 1 step or 2 steps at a time.

Key observations:
- If n = 0, there's 1 way (do nothing)
- If n = 1, there's 1 way (take 1 step)
- For n > 1: ways[n] = ways[n-1] + ways[n-2]
- This is essentially the Fibonacci sequence with different starting values

---

## CONSTRAINT UNDERSTANDING

From the problem and transcript:
1. n can be from 1 to 45 (as mentioned in transcript)
2. Recursive solution without memoization has O(2^n) time complexity
3. With memoization: O(n) time, O(n) space
4. Optimal solution: O(n) time, O(1) space

---

# BRUTE FORCE APPROACH

## First Thought Intuition

The natural approach is to try all possible combinations of 1-step and 2-step moves using recursion. At each step, we have two choices: take 1 step or take 2 steps.

## Thought Process (Step-wise)

1. Start at step 0, need to reach step n
2. At each position, we have two options:
   - Take 1 step forward (current position + 1)
   - Take 2 steps forward (current position + 2)
3. If we reach exactly step n, we found a valid way
4. If we overshoot (go beyond n), it's invalid
5. Count all valid ways

## Pseudocode

```
function climbStairs(current, n):
    if current > n:       // Overshoot, invalid
        return 0
    if current == n:      // Reached top, valid way
        return 1
    
    // Try both options
    ways = climbStairs(current + 1, n) + climbStairs(current + 2, n)
    return ways
```

## Algorithm

1. Define recursive function starting at position 0
2. Check if current position exceeds n → return 0 (invalid)
3. Check if current position equals n → return 1 (valid way)
4. Recursively try both options (1 step and 2 steps)
5. Sum results from both options

## CODE (C++ and JavaScript)

### C++

#### V1 (Only Required Function as per Platform)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        return solve(0, n);
    }
    
private:
    int solve(int current, int n) {
        // If we've passed the top, invalid path
        if (current > n) {
            return 0;
        }
        // If we've reached exactly the top, valid path
        if (current == n) {
            return 1;
        }
        
        // Try both options: 1 step or 2 steps
        return solve(current + 1, n) + solve(current + 2, n);
    }
};
```

#### V2 (Complete Program)

```cpp
#include <iostream>
using namespace std;

// Recursive function to count ways
int solve(int current, int n) {
    // Base case 1: Overshot the top, invalid path
    if (current > n) {
        return 0;
    }
    // Base case 2: Reached exactly the top, valid path
    if (current == n) {
        return 1;
    }
    
    // Recursive case: Try both 1-step and 2-step moves
    return solve(current + 1, n) + solve(current + 2, n);
}

// Main function to count ways to climb stairs
int climbStairs(int n) {
    // Start from position 0
    return solve(0, n);
}

int main() {
    // Test cases from the transcript
    int test_cases[] = {1, 2, 3, 4, 5, 10, 20};
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    cout << "Climbing Stairs - Brute Force Recursive Approach:" << endl;
    for (int i = 0; i < num_tests; i++) {
        int n = test_cases[i];
        int result = climbStairs(n);
        cout << "Ways to climb " << n << " stairs = " << result << endl;
    }
    
    return 0;
}
```

### JavaScript

#### V1 (Only Required Function as per Platform)

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    return solve(0, n);
    
    function solve(current, n) {
        // If overshot the top, invalid path
        if (current > n) {
            return 0;
        }
        // If reached exactly the top, valid path
        if (current === n) {
            return 1;
        }
        
        // Try both options: 1 step or 2 steps
        return solve(current + 1, n) + solve(current + 2, n);
    }
};
```

#### V2 (Complete Program)

```javascript
// Recursive function to count ways
function solve(current, n) {
    // Base case 1: Overshot the top, invalid path
    if (current > n) {
        return 0;
    }
    // Base case 2: Reached exactly the top, valid path
    if (current === n) {
        return 1;
    }
    
    // Recursive case: Try both 1-step and 2-step moves
    return solve(current + 1, n) + solve(current + 2, n);
}

// Main function to count ways to climb stairs
function climbStairs(n) {
    // Start from position 0
    return solve(0, n);
}

// Test cases from the transcript
const testCases = [1, 2, 3, 4, 5, 10, 20];

console.log("Climbing Stairs - Brute Force Recursive Approach:");
for (const n of testCases) {
    const result = climbStairs(n);
    console.log(`Ways to climb ${n} stairs = ${result}`);
}
```

## Time and Space Complexity

**Time Complexity:** O(2^n)
- Each call creates 2 more calls
- Forms a binary tree of height n
- Total nodes ≈ 2^n

**Space Complexity:** O(n)
- Maximum depth of recursion stack = n
- Each call uses constant space on stack

## Dry Run (All Cases)

**For n = 3:**
```
solve(0, 3):
  current=0 < 3, not == 3
  return solve(1, 3) + solve(2, 3)

solve(1, 3):
  return solve(2, 3) + solve(3, 3)

solve(2, 3):
  return solve(3, 3) + solve(4, 3)

solve(3, 3): current == n → return 1
solve(4, 3): current > n → return 0
So solve(2, 3) = 1 + 0 = 1

Back to solve(1, 3):
solve(3, 3): return 1
So solve(1, 3) = 1 + 1 = 2

Now solve(2, 3) from first call:
  return solve(3, 3) + solve(4, 3) = 1 + 0 = 1

Final: solve(0, 3) = 2 + 1 = 3 ✓
```

## Edge Cases

1. **n = 0**: Should return 1 (do nothing)
2. **n = 1**: 1 way (take 1 step)
3. **n = 2**: 2 ways (1+1 or 2)
4. **Large n (e.g., 45)**: Will timeout due to exponential time

## How This Approach Handles the Problem

It explores all possible combinations of 1-step and 2-step moves using recursion, counting all valid paths.

## Does This Approach Fail?

**YES**

**Where it fails:**
- For n > 30, takes too long (exponential time)
- Recalculates same subproblems many times
- Mentioned in transcript: "for 45 this time limit will be one seat"

**Why it fails:**
- Exponential time complexity O(2^n)
- Repeating subproblems not stored
- Not efficient for n up to 45

---

# BETTER APPROACH (Memoization/Top-Down DP)

## First Thought Intuition

Store already computed results to avoid recalculating same subproblems. Instead of starting from bottom (0), we can think from top: to reach step n, we can come from step n-1 or n-2.

## Thought Process (Step-wise)

1. Let ways[n] = number of ways to reach step n
2. Base cases:
   - ways[0] = 1 (starting point)
   - ways[1] = 1 (only 1 step from 0)
3. Recursive relation: ways[n] = ways[n-1] + ways[n-2]
4. Use memoization to store computed values

## Pseudocode

```
function climbStairs(n, memo):
    if n <= 1:
        return 1
    
    if memo[n] != -1:
        return memo[n]
    
    memo[n] = climbStairs(n-1, memo) + climbStairs(n-2, memo)
    return memo[n]
```

## Algorithm

1. Create memoization array of size n+1, initialized to -1
2. Define recursive function that takes n and memo
3. Check base cases (n = 0 or 1)
4. Check if result already in memo
5. Compute result using recursive relation
6. Store result in memo before returning

## CODE (C++ and JavaScript)

### C++

#### V1 (Only Required Function)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        // Create memoization array (n+1 because we need index n)
        vector<int> memo(n + 1, -1);
        return solve(n, memo);
    }
    
private:
    int solve(int n, vector<int>& memo) {
        // Base cases: 0 or 1 step has 1 way
        if (n <= 1) {
            return 1;
        }
        
        // If already computed, return from memo
        if (memo[n] != -1) {
            return memo[n];
        }
        
        // Compute and store in memo
        memo[n] = solve(n - 1, memo) + solve(n - 2, memo);
        return memo[n];
    }
};
```

#### V2 (Complete Program with main and tests)

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Recursive function with memoization
int solve(int n, vector<int>& memo) {
    // Base cases: 
    // ways[0] = 1 (starting point)
    // ways[1] = 1 (only 1 way: take 1 step from 0)
    if (n <= 1) {
        return 1;
    }
    
    // If result already computed, return from memo
    if (memo[n] != -1) {
        return memo[n];
    }
    
    // Recursive relation: ways[n] = ways[n-1] + ways[n-2]
    memo[n] = solve(n - 1, memo) + solve(n - 2, memo);
    return memo[n];
}

// Main function with memoization
int climbStairs(int n) {
    // Create memoization array
    // Size n+1 to store results for indices 0 to n
    vector<int> memo(n + 1, -1);
    return solve(n, memo);
}

int main() {
    // Test cases including n=45 from transcript
    int test_cases[] = {1, 2, 3, 4, 5, 10, 20, 45};
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    cout << "Climbing Stairs - Memoization (Top-Down DP):" << endl;
    for (int i = 0; i < num_tests; i++) {
        int n = test_cases[i];
        int result = climbStairs(n);
        cout << "Ways to climb " << n << " stairs = " << result << endl;
    }
    
    return 0;
}
```

### JavaScript

#### V1 (Only Required Function)

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    // Create memoization array
    const memo = new Array(n + 1).fill(-1);
    
    function solve(k) {
        // Base cases: 0 or 1 step has 1 way
        if (k <= 1) {
            return 1;
        }
        
        // If already computed, return from memo
        if (memo[k] !== -1) {
            return memo[k];
        }
        
        // Compute and store in memo
        memo[k] = solve(k - 1) + solve(k - 2);
        return memo[k];
    }
    
    return solve(n);
};
```

#### V2 (Complete Program with tests)

```javascript
// Function to compute ways to climb stairs with memoization
function climbStairs(n) {
    // Create memoization array
    const memo = new Array(n + 1).fill(-1);
    
    // Recursive helper function
    function solve(k) {
        // Base cases:
        // ways[0] = 1 (starting point)
        // ways[1] = 1 (only 1 way: take 1 step from 0)
        if (k <= 1) {
            return 1;
        }
        
        // If already computed, return from memo
        if (memo[k] !== -1) {
            return memo[k];
        }
        
        // Recursive relation: ways[k] = ways[k-1] + ways[k-2]
        memo[k] = solve(k - 1) + solve(k - 2);
        return memo[k];
    }
    
    return solve(n);
}

// Test cases including n=45 from transcript
const testCases = [1, 2, 3, 4, 5, 10, 20, 45];

console.log("Climbing Stairs - Memoization (Top-Down DP):");
for (const n of testCases) {
    const result = climbStairs(n);
    console.log(`Ways to climb ${n} stairs = ${result}`);
}
```

## Time and Space Complexity

**Time Complexity:** O(n)
- Each subproblem computed only once
- n+1 unique states to compute

**Space Complexity:** O(n)
- Memoization array of size n+1
- Recursion stack depth O(n)

## Dry Run (All Cases)

**For n = 4:**
```
solve(4): memo[4] = -1 → compute
  solve(3): memo[3] = -1 → compute
    solve(2): memo[2] = -1 → compute
      solve(1): return 1
      solve(0): return 1
      memo[2] = 1 + 1 = 2
    solve(1): return 1
    memo[3] = 2 + 1 = 3
  solve(2): memo[2] = 2 (already computed)
  memo[4] = 3 + 2 = 5
Return 5 ✓
```

## Edge Cases

1. **n = 0**: Returns 1 (starting point)
2. **n = 1**: Returns 1
3. **n = 45**: Works efficiently with memoization
4. **Very large n**: Works but recursion depth might cause stack overflow

## How This Approach Handles the Problem

Stores computed results to avoid recomputation, converting exponential time to linear. Uses the insight: to reach step n, you must come from step n-1 or n-2.

## Does This Approach Fail?

**NO** for correctness, but has **limitations**:
- Recursion depth limit for very large n
- Can cause stack overflow
- Extra overhead of recursion calls

This is acceptable but we can do better with bottom-up approach.

---

# OPTIMAL APPROACH (Bottom-Up DP / Space Optimized)

## First Thought Intuition

Instead of recursion, build solution iteratively from base cases. Since we only need last two values, we can use constant space. This is the "bottom-up" approach mentioned in the transcript.

## Thought Process (Step-wise)

1. Base cases: dp[0] = 1, dp[1] = 1
2. For i from 2 to n: dp[i] = dp[i-1] + dp[i-2]
3. Observation: we only need dp[i-1] and dp[i-2] to compute dp[i]
4. So we can use just 3 variables: prev2, prev1, current

## Pseudocode

```
function climbStairs(n):
    if n <= 1:
        return 1
    
    prev2 = 1  // dp[0]
    prev1 = 1  // dp[1]
    
    for i from 2 to n:
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1
```

## Algorithm

1. Handle base cases (n = 0 or 1)
2. Initialize variables for dp[0] and dp[1]
3. Iterate from 2 to n, computing dp[i] using dp[i-1] and dp[i-2]
4. Update variables for next iteration
5. Return result

## CODE (C++ and JavaScript)

### C++

#### V1 (Only Required Function)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        // Base cases: 0 or 1 step has 1 way
        if (n <= 1) {
            return 1;
        }
        
        // Initialize with dp[0] and dp[1]
        int prev2 = 1;  // dp[0] = 1 (starting point)
        int prev1 = 1;  // dp[1] = 1 (only 1 step from 0)
        int current;
        
        // Build solution from bottom up
        for (int i = 2; i <= n; i++) {
            current = prev1 + prev2;  // dp[i] = dp[i-1] + dp[i-2]
            prev2 = prev1;  // Update for next iteration
            prev1 = current;
        }
        
        return prev1;  // This holds dp[n]
    }
};
```

#### V2 (Complete Program with main and tests)

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Method 1: Bottom-up DP with array (for understanding)
int climbStairsDP(int n) {
    if (n <= 1) return 1;
    
    vector<int> dp(n + 1);
    dp[0] = 1;  // Starting point
    dp[1] = 1;  // Only 1 way: take 1 step
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    
    return dp[n];
}

// Method 2: Space-optimized version (optimal)
int climbStairs(int n) {
    // Base cases
    if (n <= 1) {
        return 1;
    }
    
    // We only need to track last two values
    int prev2 = 1;  // Represents dp[i-2]
    int prev1 = 1;  // Represents dp[i-1]
    int current;
    
    // Iteratively build from 2 to n
    for (int i = 2; i <= n; i++) {
        // Current number of ways
        current = prev1 + prev2;
        
        // Update for next iteration
        prev2 = prev1;
        prev1 = current;
    }
    
    return prev1;  // This holds dp[n]
}

int main() {
    // Test cases from transcript
    int test_cases[] = {1, 2, 3, 4, 5, 10, 20, 45};
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    cout << "Climbing Stairs - Optimized Bottom-Up DP:" << endl;
    cout << "(Note: This is essentially Fibonacci starting with 1, 1)" << endl;
    for (int i = 0; i < num_tests; i++) {
        int n = test_cases[i];
        int result = climbStairs(n);
        cout << "Ways to climb " << n << " stairs = " << result << endl;
    }
    
    // Show relation to Fibonacci
    cout << "\nRelation to Fibonacci sequence:" << endl;
    cout << "climbStairs(n) = Fibonacci(n+1)" << endl;
    cout << "Where Fibonacci: F(0)=0, F(1)=1, F(2)=1, F(3)=2, etc." << endl;
    
    return 0;
}
```

### JavaScript

#### V1 (Only Required Function)

```javascript
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    // Base cases: 0 or 1 step has 1 way
    if (n <= 1) {
        return 1;
    }
    
    // Initialize with dp[0] and dp[1]
    let prev2 = 1;  // dp[0] = 1 (starting point)
    let prev1 = 1;  // dp[1] = 1 (only 1 step from 0)
    let current;
    
    // Build solution iteratively
    for (let i = 2; i <= n; i++) {
        current = prev1 + prev2;  // dp[i] = dp[i-1] + dp[i-2]
        prev2 = prev1;  // Update for next iteration
        prev1 = current;
    }
    
    return prev1;  // This holds dp[n]
};
```

#### V2 (Complete Program with tests)

```javascript
// Method 1: Bottom-up DP with array (for understanding)
function climbStairsDP(n) {
    if (n <= 1) return 1;
    
    const dp = new Array(n + 1);
    dp[0] = 1;  // Starting point
    dp[1] = 1;  // Only 1 way: take 1 step
    
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    
    return dp[n];
}

// Method 2: Space-optimized version (optimal)
function climbStairs(n) {
    // Base cases
    if (n <= 1) {
        return 1;
    }
    
    // We only need to track last two values
    let prev2 = 1;  // Represents dp[i-2]
    let prev1 = 1;  // Represents dp[i-1]
    let current;
    
    // Iteratively build from 2 to n
    for (let i = 2; i <= n; i++) {
        // Current number of ways
        current = prev1 + prev2;
        
        // Update for next iteration
        prev2 = prev1;
        prev1 = current;
    }
    
    return prev1;  // This holds dp[n]
}

// Test cases from transcript
const testCases = [1, 2, 3, 4, 5, 10, 20, 45];

console.log("Climbing Stairs - Optimized Bottom-Up DP:");
console.log("(Note: This is essentially Fibonacci starting with 1, 1)");
for (const n of testCases) {
    const result = climbStairs(n);
    console.log(`Ways to climb ${n} stairs = ${result}`);
}

// Show relation to Fibonacci
console.log("\nRelation to Fibonacci sequence:");
console.log("climbStairs(n) = Fibonacci(n+1)");
console.log("Where Fibonacci: F(0)=0, F(1)=1, F(2)=1, F(3)=2, etc.");
```

## Time and Space Complexity

**Time Complexity:** O(n)
- Single loop from 2 to n
- Constant work per iteration

**Space Complexity:** O(1)
- Only 3 variables used (prev2, prev1, current)
- No extra arrays or recursion stack

## Dry Run (All Cases)

**For n = 4:**
```
n=4 (>1)
prev2=1, prev1=1 (dp[0] and dp[1])
i=2: current=1+1=2, prev2=1, prev1=2
i=3: current=2+1=3, prev2=2, prev1=3
i=4: current=3+2=5, prev2=3, prev1=5
Return prev1=5 ✓
```

## Edge Cases

1. **n = 0**: Returns 1 (starting point, handled by base case)
2. **n = 1**: Returns 1 (only 1 way, handled by base case)
3. **n = 2**: Loop runs once, returns 2
4. **n = 45**: Works efficiently with O(n) time, O(1) space

## How This Approach Handles the Problem

Builds solution iteratively from base cases using the recurrence relation: ways[n] = ways[n-1] + ways[n-2]. Since we only need the last two values, we can use constant space.

## Why This Is Optimal

1. **Time Complexity O(n)**: Must compute all values from 0 to n at least once → Ω(n) time
2. **Space Complexity O(1)**: Mathematical property: ways[n] depends only on ways[n-1] and ways[n-2]
3. **No recursion overhead**: Avoids stack overflow risk
4. **Minimal memory usage**: Only 3 variables needed

**Mathematical Insight**:  
This is essentially the Fibonacci sequence shifted:
- climbStairs(n) = F(n+1) where F is Fibonacci with F(0)=0, F(1)=1
- Sequence: 1, 1, 2, 3, 5, 8, 13, 21, ...

**From transcript**: The lecturer explains this is "bottom up" approach where we build from smaller solutions to bigger solutions, using the insight that to reach step i, we must come from step i-1 or i-2.