## Concepts: Understanding Binary Search

Problem Link: [LeetCode 704. Binary Search](https://leetcode.com/problems/binary-search/)


**What is Binary Search?**

Binary Search is a searching algorithm used to find an element in a **sorted search space**. It works by repeatedly dividing the search space in half, eliminating one half based on a comparison with the middle element, until the target is found or the search space is exhausted.

**Logical Explanation in Simple Words**:

- **Real-Life Example (Dictionary)**: Imagine youâ€™re looking for the word "Raj" in a dictionary. A dictionary is sorted alphabetically (A, B, C, ..., Z). Instead of checking every page from start to end (linear search), you:
    - Open the dictionary in the middle.
    - If the middle page shows words starting with â€˜Sâ€™, you know â€˜Sâ€™ and later letters (T, U, ..., Z) are on the right, and â€˜Aâ€™ to â€˜Râ€™ are on the left.
    - Since â€˜Rajâ€™ starts with â€˜Râ€™ (before â€˜Sâ€™), you ignore the right half and focus on the left half.
    - You repeat this process, splitting the left half again, until you find â€˜Rajâ€™ or realize itâ€™s not there.
    - *Hinglish*: Dictionary mein â€˜Rajâ€™ dhoondhna hai. Poora page-by-page check nahi karenge. Beech mein kholo, agar â€˜Sâ€™ wala word hai, to â€˜Rajâ€™ left side mein hoga kyunki â€˜Râ€™ < â€˜Sâ€™. Left half ko phir se divide karo, aise hi continue karo.
- **Key Property**: Binary Search works only if the search space is **sorted** (e.g., dictionary words in alphabetical order or an array in ascending order). This allows us to eliminate half the search space in each step.
- **How It Works**:
    - Start with the entire search space (e.g., full dictionary or array).
    - Find the middle point (middle page or array index).
    - Compare the middle element with the target:
        - If theyâ€™re equal, youâ€™ve found the target.
        - If the target is smaller, ignore the right half (elements are larger).
        - If the target is larger, ignore the left half (elements are smaller).
    - Repeat in the remaining half until the target is found or the search space is empty.
- **Why Itâ€™s Efficient**: Instead of checking every element (like linear search, which takes O(n) time), Binary Search cuts the search space in half each time, making it much faster (O(log n) time).
- **Hinglish**: Sorted array ya dictionary mein search karna hai? Beech se shuru karo, target se compare karo. Agar target chhota hai, left half lo; agar bada hai, right half lo. Har baar search space aadha ho jata hai, isliye jaldi milta hai.

**Key Terms**:

- **Search Space**: The range of elements/positions where the target might exist (e.g., entire array or dictionary pages).
- **Low and High Pointers**: Mark the start (`low`) and end (`high`) of the current search space.
- **Mid Point**: The middle index of the search space, calculated as `(low + high) / 2`.
- **Sorted**: Elements are in order (e.g., ascending in an array or alphabetical in a dictionary).
- **Hinglish**: `low` aur `high` search space ke start aur end hain. `mid` beech ka point hai. Sorted means sab numbers ya words ek order mein hain.

**When to Use Binary Search**:

- Use it when the search space is **sorted** (array, dictionary, or other problems like finding an answer in a sorted range).
- Itâ€™s not just for arrays; it can apply to any sorted range (e.g., finding a page number, a value, or an optimal answer).
- *Hinglish*: Jab bhi sorted cheez mein search karna hoâ€”array ho, dictionary ho, ya koi aur problemâ€”Binary Search try karo.

**Overflow Case**:

- When calculating `mid = (low + high) / 2`, if `low` and `high` are very large (e.g., near `INT_MAX`), `low + high` can overflow an integer.
- **Solution 1**: Use `long long` for `low` and `high` to handle large values.
- **Solution 2**: Calculate `mid` as `low + (high - low) / 2`. This avoids overflow because `high - low` is smaller, and adding it to `low` stays within bounds.
- *Hinglish*: Agar `low` aur `high` bade numbers hain, to `low + high` overflow kar sakta hai. Iske liye `long long` use karo ya `mid = low + (high - low) / 2` likho, safe rahega.

**Time Complexity**:

- Each step halves the search space (e.g., 32 â†’ 16 â†’ 8 â†’ 4 â†’ 2 â†’ 1).
- For an array of size `n`, it takes about `logâ‚‚(n)` steps (e.g., for `n=32=2âµ`, it takes ~5 steps).
- Total time: `O(log n)`.
- *Hinglish*: Har step mein search space half ho jata hai. 32 ka array ho to 5 steps mein khatam, isliye time `log n` hai.

**Why Learn This?**:

- Binary Search is a fundamental algorithm used in many problems beyond simple array searching (e.g., finding boundaries, optimizing answers).
- Itâ€™s a common interview topic, and understanding its logic helps tackle advanced problems.
- *Hinglish*: Binary Search seekhna zaroori hai kyunki yeh bahut saare problems mein kaam aata hai, aur interviews mein bhi poochha jata hai.

---

## Problem: Binary Search in a Sorted Array

**Problem Statement**:

Given a sorted array of unique integers `arr` (in ascending order, no duplicates) and a target value `target`, find the index of `target` in the array. If the target is not present, return `-1`.

**Breakdown**:

- **Input**:
    - Sorted integer array `arr` (no duplicates).
    - Integer `target` to find.
- **Output**:
    - Integer: Index of `target` if found, else `1`.
- **What We Need to Do**: Use Binary Search to efficiently find the target by dividing the search space in half repeatedly, leveraging the sorted property of the array.
- **Why is This a Problem?**: Linear search (checking each element) is slow (O(n)). Binary Search uses the sorted property to reduce the search space, achieving O(log n) time.
- **Hinglish**: Ek sorted array hai, usme `target` ka index dhoondhna hai. Agar nahi hai to `1` return karo. Har baar array ko half karke check karenge, kyunki sorted hai to half portion hata sakte hain.

**Constraints**:

- `1 <= arr.length <= 10^5`.
- `10^4 <= arr[i], target <= 10^4`.
- Array is sorted in ascending order with no duplicates.

**Examples**:

- **Example 1**:
    - Input: `arr = [3,4,6,7,9,12,16,17]`, `target = 6`
    - Output: `2`
    - Explanation: `6` is at index `2` (0-based).
- **Example 2**:
    - Input: `arr = [3,4,6,7,9,12,16,17]`, `target = 13`
    - Output: `1`
    - Explanation: `13` is not in the array.
- **Example 3**:
    - Input: `arr = [1]`, `target = 1`
    - Output: `0`
    - Explanation: Single element array, `1` is at index `0`.

**Key Definitions**:

- **Sorted Array**: Elements in ascending order (e.g., `[3,4,6,7,9]`).
- **Target**: The value to find in the array.
- **Index**: 0-based position of the target in the array.
- **Hinglish**: Sorted array means numbers chhote se bade tak hain. `target` ko dhoondhna hai, agar milta hai to uska index do, nahi to `1`.

---

### Approaches for Binary Search

### ğŸ”´ Approach 1: Iterative Binary Search

**Thought Process**:

- **Goal**: Find the targetâ€™s index in a sorted array or return `1` if not found.
- **How to Model**: Use two pointers (`low` and `high`) to define the search space. Calculate the middle index (`mid`), compare `arr[mid]` with `target`, and adjust the search space based on the comparison.
- **Choices**: Iterative approach uses a loop to avoid recursion overhead. Check `arr[mid] == target`, `arr[mid] < target`, or `arr[mid] > target` to decide which half to keep.
- **Constraints**: `O(log n)` time (halving search space), `O(1)` space (no extra data structures).
- **Hinglish**: Do pointers `low` aur `high` se search space rakho. Beech ka `mid` nikalo, `arr[mid]` ko `target` se compare karo. Agar `target` bada hai, right half lo; chhota hai, left half lo. Loop chalao jab tak search space khatam na ho.

**Examples to Prove Idea**:

- `arr = [3,4,6,7,9,12,16,17]`, `target = 6`:
    - Start: `low=0`, `high=7`, `mid=(0+7)/2=3`, `arr[3]=7`. Since `7 > 6`, search left half (`high=mid-1=2`).
    - Next: `low=0`, `high=2`, `mid=(0+2)/2=1`, `arr[1]=4`. Since `4 < 6`, search right half (`low=mid+1=2`).
    - Next: `low=2`, `high=2`, `mid=(2+2)/2=2`, `arr[2]=6`. Found `target`, return `2`.
- `arr = [3,4,6,7,9,12,16,17]`, `target = 13`:
    - Start: `low=0`, `high=7`, `mid=3`, `arr[3]=7`. Since `7 < 13`, search right half (`low=mid+1=4`).
    - Next: `low=4`, `high=7`, `mid=(4+7)/2=5`, `arr[5]=12`. Since `12 < 13`, search right half (`low=mid+1=6`).
    - Next: `low=6`, `high=7`, `mid=(6+7)/2=6`, `arr[6]=16`. Since `16 > 13`, search left half (`high=mid-1=5`).
    - Now: `low=6`, `high=5`. Since `low > high`, search space is empty, return `1`.
- *Why It Works*: Each step halves the search space, and the sorted property ensures we can eliminate half based on comparisons.

**Intuition**:

Maintain a search space between `low` and `high` indices. Compute the middle index `mid`. Compare `arr[mid]` with `target`:

- If equal, return `mid`.
- If `target < arr[mid]`, search left half (`high = mid-1`).
- If `target > arr[mid]`, search right half (`low = mid+1`).
Continue until `low <= high`. If the search space is exhausted (`low > high`), return `1`. The sorted array ensures we can always eliminate half the elements.

**Dry Run**:

- Input: `arr = [3,4,6,7,9,12,16,17]`, `target = 6`.
- Initialize: `low = 0`, `high = 7`, `n = 8`.
- Loop:
    - Step 1: `low=0`, `high=7`, `mid=(0+7)/2=3`, `arr[3]=7`. Since `7 > 6`, set `high=mid-1=2`.
    - Step 2: `low=0`, `high=2`, `mid=(0+2)/2=1`, `arr[1]=4`. Since `4 < 6`, set `low=mid+1=2`.
    - Step 3: `low=2`, `high=2`, `mid=(2+2)/2=2`, `arr[2]=6`. Since `6 == 6`, return `2`.
- Return: `2`.
- *Hinglish*: Shuru mein `low=0`, `high=7`. `mid=3` pe `7` hai, `6` se bada, to right half hatao (`high=2`). Phir `mid=1` pe `4` hai, `6` se chhota, to left half hatao (`low=2`). Phir `mid=2` pe `6` mil gaya, to index `2` return karo.

**Algorithm**:

1. Initialize `low = 0`, `high = arr.length - 1`.
2. While `low <= high`:
    - Compute `mid = (low + high) / 2`.
    - If `arr[mid] == target`, return `mid`.
    - If `arr[mid] < target`, search right half: set `low = mid + 1`.
    - Else (`arr[mid] > target`), search left half: set `high = mid - 1`.
3. If loop ends (`low > high`), return `1`.

**Pseudocode**:

```cpp
function binarySearchIterative(arr, target):
    low = 0
    high = arr.length - 1
    while low <= high:
        mid = (low + high) / 2
        if arr[mid] == target:
            return mid
        else if arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

```

**Code**:

```cpp
#include <bits/stdc++.h>
using namespace std;

int binarySearchIterative(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}

```

**Time Complexity (TC)**:

- Each iteration halves the search space: `n â†’ n/2 â†’ n/4 â†’ ... â†’ 1`.
- Number of steps is approximately `logâ‚‚(n)` (e.g., for `n=32=2âµ`, ~5 steps).
- Total TC: `O(log n)`.
- Why? The search space reduces exponentially, and each comparison is O(1).

**Space Complexity (SC)**:

- `O(1)` (only uses `low`, `high`, `mid` variables).
- Why? No additional data structures are needed.

**Notes/Observations**:

- *Why this approach?* Simple, efficient, and avoids recursion overhead. Ideal for interviews due to clarity and O(log n) time.
- *Hinglish*: Loop se search space half karte jao, `mid` pe check karo, aur half hatao. Simple aur fast hai.
- *Limitation*: Requires sorted array. For large `n`, watch for integer overflow in `mid` calculation (use `low + (high - low) / 2`).

---

### ğŸŸ¢ Approach 2: Recursive Binary Search

**Thought Process**:

- **Goal**: Same as iterative: find the targetâ€™s index or return `1`.
- **How to Model**: Use recursion to perform the same steps (compute `mid`, compare, search one half) by calling the function with updated `low` or `high`.
- **Choices**: Recursive approach is elegant but uses call stack space. Base case stops when search space is empty (`low > high`).
- **Constraints**: `O(log n)` time (same halving logic), `O(log n)` space (due to recursive call stack).
- **Hinglish**: Same kaam recursion se karo. Har baar `mid` check karo, aur ek half mein function ko dobara call karo. Jab search space khatam (`low > high`), to `1` return karo.

**Examples to Prove Idea**:

- `arr = [3,4,6,7,9,12,16,17]`, `target = 13`:
    - Call: `low=0`, `high=7`, `mid=3`, `arr[3]=7`. Since `7 < 13`, call function with `low=4`, `high=7`.
    - Call: `low=4`, `high=7`, `mid=5`, `arr[5]=12`. Since `12 < 13`, call with `low=6`, `high=7`.
    - Call: `low=6`, `high=7`, `mid=6`, `arr[6]=16`. Since `16 > 13`, call with `low=6`, `high=5`.
    - Call: `low=6`, `high=5`. Since `low > high`, return `1`.
- *Why It Works*: Recursion mimics iterative logic, halving the search space each call, and stops when the target is found or search space is empty.

**Intuition**:

Define a recursive function that takes `arr`, `target`, `low`, and `high`. Compute `mid` and compare `arr[mid]` with `target`:

- If equal, return `mid`.
- If `target < arr[mid]`, recurse on left half (`low`, `mid-1`).
- If `target > arr[mid]`, recurse on right half (`mid+1`, `high`).
Base case: If `low > high`, return `1`. Each recursive call reduces the search space by half.

**Dry Run**:

- Input: `arr = [3,4,6,7,9,12,16,17]`, `target = 13`.
- Call 1: `low=0`, `high=7`, `mid=(0+7)/2=3`, `arr[3]=7`. Since `7 < 13`, recurse with `low=4`, `high=7`.
- Call 2: `low=4`, `high=7`, `mid=(4+7)/2=5`, `arr[5]=12`. Since `12 < 13`, recurse with `low=6`, `high=7`.
- Call 3: `low=6`, `high=7`, `mid=(6+7)/2=6`, `arr[6]=16`. Since `16 > 13`, recurse with `low=6`, `high=5`.
- Call 4: `low=6`, `high=5`. Since `low > high`, return `1`.
- Return: `1` propagates back through calls.
- *Hinglish*: Pehla call: `mid=3`, `7 < 13`, to right half mein jao (`low=4`). Doosra call: `mid=5`, `12 < 13`, phir right (`low=6`). Teesra call: `mid=6`, `16 > 13`, left mein jao (`high=5`). Ab `low > high`, to `1` return karo.

**Algorithm**:

1. Define recursive function `binarySearch(arr, target, low, high)`:
    - If `low > high`, return `1` (base case).
    - Compute `mid = (low + high) / 2`.
    - If `arr[mid] == target`, return `mid`.
    - If `arr[mid] < target`, recurse with `low=mid+1`, `high`.
    - Else, recurse with `low`, `high=mid-1`.
2. Call function with `low=0`, `high=arr.length-1`.

**Pseudocode**:

```cpp
function binarySearchRecursive(arr, target, low, high):
    if low > high:
        return -1
    mid = (low + high) / 2
    if arr[mid] == target:
        return mid
    else if arr[mid] < target:
        return binarySearchRecursive(arr, target, mid + 1, high)
    else:
        return binarySearchRecursive(arr, target, low, mid - 1)

function binarySearch(arr, target):
    return binarySearchRecursive(arr, target, 0, arr.length - 1)

```

**Code**:

```cpp
#include <bits/stdc++.h>
using namespace std;

int binarySearchRecursive(vector<int>& arr, int target, int low, int high) {
    if (low > high) {
        return -1;
    }
    int mid = (low + high) / 2;
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, high);
    } else {
        return binarySearchRecursive(arr, target, low, mid - 1);
}

int binarySearch(vector<int>& arr, int target) {
    return binarySearchRecursive(arr, target, 0, arr.size() - 1);
}

```

**Java Equivalent**:

```java
class Solution {
    public int binarySearch(int[] arr, int target) {
        return binarySearchRecursive(arr, target, 0, arr.length - 1);
    }

    private int binarySearchRecursive(int[] arr, int target, int low, int high) {
        if (low > high) {
            return -1;
        }
        int mid = (low + high) / 2;
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            return binarySearchRecursive(arr, target, mid + 1, high);
        } else {
            return binarySearchRecursive(arr, target, low, mid - 1);
        }
    }
}

```

**Time Complexity (TC)**:

- Each recursive call halves the search space, requiring `logâ‚‚(n)` steps.
- Total TC: `O(log n)`.
- Why? Same halving logic as iterative, with each call performing O(1) operations.

**Space Complexity (SC)**:

- `O(log n)` (due to recursive call stack, with up to `log n` calls).
- Why? Each recursive call adds a layer to the stack until the base case or target is found.

**Notes/Observations**:

- *Why this approach?* Elegant and reusable for problems requiring repeated halving. Shows recursion understanding in interviews.
- *Hinglish*: Recursion se same kaam karo, bas function khud ko call karta hai with smaller search space. Stack space zyada lagta hai.
- *Limitation*: Extra space due to call stack. Iterative is preferred for large `n` to avoid stack overflow.

---

### Final Consolidated Code

```cpp
#include <bits/stdc++.h>
using namespace std;

// ğŸ§  Problem: Binary Search in a Sorted Array
// Example: arr = [3,4,6,7,9,12,16,17], target = 6 â†’ 2
// Constraints: 1 <= arr.length <= 10^5, -10^4 <= arr[i], target <= 10^4, sorted, no duplicates

// ğŸ”´ Iterative Binary Search
// TC: O(log n), SC: O(1)
int binarySearchIterative(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2; // Avoid overflow
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return -1;
}

// ğŸŸ¢ Recursive Binary Search
// TC: O(log n), SC: O(log n)
int binarySearchRecursive(vector<int>& arr, int target, int low, int high) {
    if (low > high) {
        return -1;
    }
    int mid = low + (high - low) / 2; // Avoid overflow
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, high);
    } else {
        return binarySearchRecursive(arr, target, low, mid - 1);
    }
}

int binarySearch(vector<int>& arr, int target) {
    return binarySearchRecursive(arr, target, 0, arr.size() - 1);
}

int main() {
    vector<int> arr = {3, 4, 6, 7, 9, 12, 16, 17};
    int target = 6;
    cout << "Iterative: " << binarySearchIterative(arr, target) << endl;
    cout << "Recursive: " << binarySearch(arr, target) << endl;
    return 0;
}

```

**Java Equivalent**:

```java
class Solution {
    // ğŸ”´ Iterative Binary Search
    // TC: O(log n), SC: O(1)
    public int binarySearchIterative(int[] arr, int target) {
        int low = 0, high = arr.length - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2; // Avoid overflow
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1;
    }

    // ğŸŸ¢ Recursive Binary Search
    // TC: O(log n), SC: O(log n)
    public int binarySearch(int[] arr, int target) {
        return binarySearchRecursive(arr, target, 0, arr.length - 1);
    }

    private int binarySearchRecursive(int[] arr, int target, int low, int high) {
        if (low > high) {
            return -1;
        }
        int mid = low + (high - low) / 2; // Avoid overflow
        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] < target) {
            return binarySearchRecursive(arr, target, mid + 1, high);
        } else {
            return binarySearchRecursive(arr, target, low, mid - 1);
        }
    }
}

```

---

### Key Points for Interview

- **Iterative Approach**: `O(log n)` time, `O(1)` space â€“ Preferred for efficiency and no stack overflow risk.
- **Recursive Approach**: `O(log n)` time, `O(log n)` space â€“ Shows recursion mastery but less practical for large `n`.
- *Hinglish*: Interview mein pehle iterative wala explain karo, kyunki yeh space bachata hai. Recursive bhi samjhao agar recursion poochha jaye. `low`, `high`, `mid` ka logic clear rakho.
- *Key Insight*: Use `mid = low + (high - low) / 2` to avoid overflow. Ensure array is sorted.
- *Edge Case Handling*:
    - Single element array (`n=1`).
    - Target not present (`return -1`).
    - Large indices (use overflow-safe `mid` calculation).

---

### Additional Notes for Beginners

- *Why this approach?* Teaches efficient searching and the power of dividing problems into smaller parts.
- *Hinglish*:
    - Iterative: Loop se search space half karte jao, `mid` check karo, aur ek half hatao. Space kam lagta hai.
    - Recursive: Function khud ko call karta hai with smaller search space. Samajhne mein asaan, par stack zyada use hota hai.
- *Practice*:
    - `arr=[3,4,6,7,9,12,16,17]`, `target=6` â†’ `2`.
    - `arr=[3,4,6,7,9,12,16,17]`, `target=13` â†’ `1`.
    - `arr=[1]`, `target=1` â†’ `0`.
- *Edge Cases*:
    - Single element: Check `arr[0]` and return `0` or `1`.
    - Empty array: Not possible per constraints (`n >= 1`).
    - Large `n`: Use `low + (high - low) / 2` to avoid overflow.
- *Interesting Property*: Binary Search is not just for arrays; it applies to any sorted search space (e.g., finding optimal answers in problems like â€œminimize maximumâ€).

---