## Search Insert Position

Problem Link: [LeetCode #35](https://leetcode.com/problems/search-insert-position/)

**Problem Statement**:

Given a sorted array of **distinct** integers `arr` (in ascending order) and a target value `x`, return the index of `x` if it exists in the array. If `x` is not present, return the index where `x` should be inserted to maintain the sorted order.

**Breakdown**:

- **Input**:
    - `arr`: Sorted array of distinct integers (no duplicates).
    - `x`: Target integer.
- **Output**: Integer representing the index of `x` if present, or the index where `x` should be inserted to keep the array sorted.
- **Objective**: Use Binary Search to efficiently find the index by leveraging the sorted property of the array.
- **Why is This a Problem?**: Linear search takes `O(n)` time, which is slow for large arrays. Binary Search reduces this to `O(log n)` by halving the search space. This problem is essentially finding the Lower Bound (smallest index `i` where `arr[i] >= x`), as it gives the position of `x` or where it would be inserted.
- *Hinglish*: Sorted array mein `x` ka index dhoondho, agar nahi hai to jahan insert hoga wahi index do. Linear search slow hai, Binary Search se jaldi milega.

**Constraints**:

- `1 <= arr.length <= 10^4`.
- `10^4 <= arr[i], x <= 10^4`.
- Array is sorted in ascending order, with **no duplicates**.

**Examples**:

- **Example 1**: `arr = [1,3,5,6]`, `x = 5` â†’ Output: `2` (`arr[2] = 5`).
- **Example 2**: `arr = [1,3,5,6]`, `x = 2` â†’ Output: `1` (insert `2` at index `1` to get `[1,2,3,5,6]`).
- **Example 3**: `arr = [1,3,5,6]`, `x = 7` â†’ Output: `4` (insert `7` at index `4`, end of array).
- **Example 4**: `arr = [1,3,5,6]`, `x = 0` â†’ Output: `0` (insert `0` at index `0` to get `[0,1,3,5,6]`).

**Key Definitions**:

- **Search Insert Position**: The index where `x` exists (if present) or where `x` should be inserted to maintain sorted order. This is equivalent to the **Lower Bound** (smallest index `i` where `arr[i] >= x`).
- **Hypothetical Index**: If `x` is larger than all elements, return `n` (array length), indicating insertion at the end.
- *Hinglish*: Yeh problem lower bound jaisa hai. `x` ka index do, ya jahan `x` insert hoga wahan ka index do, taaki array sorted rahe.

**Concepts** (from Lecture):

- **Binary Search for Search Insert Position**: This problem is identical to finding the Lower Bound. Binary Search finds the target efficiently in a sorted array by halving the search space. We check if `arr[mid] >= x`. If true, this is a candidate (either `x` itself or where `x` would be inserted), but we search left to find a smaller index. If `arr[mid] < x`, we search right since smaller elements canâ€™t satisfy the condition.
- **Key Property**: The array must be sorted and has no duplicates, simplifying the logic as we donâ€™t need to handle multiple occurrences.
- **Answer Variable**: Use an `ans` variable to store the smallest valid index, initialized to `n` (hypothetical insertion point if `x` is larger than all elements).
- **Overflow Handling**: Calculate `mid` as `low + (high - low) / 2` to avoid integer overflow when `low + high` is large.
- *Hinglish*: Binary Search mein array sorted hona chahiye. `arr[mid] >= x` ho to index save karo par left jao kyunki chhota index chahiye. `arr[mid] < x` ho to right jao. `mid` nikalte waqt overflow se bachne ke liye `low + (high - low) / 2` use karo.
- **Time Complexity**: `O(log n)` because the search space halves each step.
- **Space Complexity**: `O(1)` for iterative approach, `O(log n)` for recursive due to call stack.
- **Why Important?**: This is a classic Binary Search problem (LeetCode #35), testing the ability to adapt Lower Bound logic to find an element or its insertion point. Itâ€™s common in interviews and related to standard libraries (e.g., C++ STL `lower_bound`).

---

### Approaches for Search Insert Position

### ðŸ”´ Approach 1: Linear Search

**Thought Process**:

- **Goal**: Find the index of `x` if present, or the index where `x` should be inserted.
- **How to Model**: Iterate through the array from index `0` to `n-1`. Return the first index `i` where `arr[i] >= x` (either `x` itself or where `x` would be inserted). If no such index is found, return `n`.
- **Choices**: Linear search is simple but doesnâ€™t leverage the sorted property, making it inefficient for large arrays.
- **Constraints**: `O(n)` time, `O(1)` space.
- *Hinglish*: Har element ko ek-ek karke check karo. Jahan pehla `arr[i] >= x` mile, wahi index return karo, kyunki wahi `x` ka index ya insert position hai. Simple hai par slow.

**Examples to Prove Idea**:

- `arr = [1,3,5,6]`, `x = 5`:
    - Check: `1 < 5`, `3 < 5`, `5 >= 5` â†’ return `2` (found `x`).
- `arr = [1,3,5,6]`, `x = 2`:
    - Check: `1 < 2`, `3 >= 2` â†’ return `1` (insert at `1`).
- `arr = [1,3,5,6]`, `x = 7`:
    - All elements `< 7` â†’ return `4` (insert at end).
- *Why It Works*: Sequentially checks each element, ensuring the first index where `arr[i] >= x` is either `x`â€™s position or the insertion point.

**Intuition**:
Loop through the array from start to end. As soon as `arr[i] >= x` is found, return `i`, as itâ€™s either the index of `x` (if `arr[i] == x`) or the position where `x` should be inserted (if `arr[i] > x`). If no element satisfies, return `n` for insertion at the end. The approach is intuitive but slow because it ignores the sorted nature of the array.

**Dry Run**:

- Input: `arr = [1,3,5,6]`, `x = 2`, `n = 4`.
- Loop:
    - `i=0`: `arr[0] = 1 < 2`. **Reason**: `1` is less than `2`, doesnâ€™t satisfy `>= 2`, move to next index.
    - `i=1`: `arr[1] = 3 >= 2`. **Reason**: `3` satisfies `>= 2`, and itâ€™s the first such index. Since `3 > 2`, `2` would be inserted at index `1` to maintain sorted order (`[1,2,3,5,6]`). Return `1`.
- Return: `1`.
- *Hinglish*: Ek-ek karke check kiya: `1 < 2`, `3 >= 2`. Index `1` pe condition mili, to `1` return karo kyunki `2` yahan insert hoga.

**Algorithm**:

1. Iterate `i` from `0` to `arr.length - 1`:
    - If `arr[i] >= x`, return `i`.
2. Return `arr.length`.

**Pseudocode**:

```cpp
function searchInsertLinear(arr, x):
    for i from 0 to arr.length - 1:
        if arr[i] >= x:
            return i
    return arr.length

```

**Code**:

```cpp
#include <bits/stdc++.h>
using namespace std;

int searchInsertLinear(vector<int>& arr, int x) {
    for (int i = 0; i < arr.size(); i++) {
        if (arr[i] >= x) return i;
    }
    return arr.size();
}

```

**Java Equivalent**:

```java
class Solution {
    public int searchInsertLinear(int[] arr, int x) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] >= x) return i;
        }
        return arr.length;
    }
}

```

**Time Complexity (TC)**:

- `O(n)`: In the worst case (e.g., `x` larger than all elements), it checks every element.
- *Why?*: Linearly traverses the array without leveraging the sorted property.

**Space Complexity (SC)**:

- `O(1)`: Only uses a loop variable.
- *Why?*: No additional data structures are needed.

**Notes/Observations**:

- *Why this approach?*: Easy to implement and understand, good for small arrays or as a baseline for interviews.
- *Hinglish*: Yeh approach simple hai, bas har element check karo. Par bade array ke liye slow hai kyunki sorted ka fayda nahi liya.
- *Limitation*: Inefficient for large `n` (e.g., `10^4`), where Binary Search is better.

---

### ðŸŸ¢ Approach 2: Binary Search (Optimized)

**Thought Process**:

- **Goal**: Find the index of `x` if present, or the index where `x` should be inserted.
- **How to Model**: This is identical to the Lower Bound problem (smallest index `i` where `arr[i] >= x`). Use Binary Search with two pointers (`low` and `high`) to define the search space. Initialize `ans = arr.length` to handle cases where `x` is larger than all elements. Compute the middle index (`mid`). If `arr[mid] >= x`, store `mid` in `ans` and search left to find a potentially smaller index (in case `x` exists earlier or a smaller insertion point exists). If `arr[mid] < x`, search right since smaller elements canâ€™t satisfy the condition.
- **Choices**: Iterative Binary Search is preferred for `O(1)` space over recursive, and the `ans` variable ensures we track the smallest valid index. Since the array has no duplicates, `arr[mid] == x` means weâ€™ve found the exact index, but we still search left to ensure itâ€™s the smallest possible index.
- **Constraints**: `O(log n)` time, `O(1)` space.
- *Hinglish*: Yeh lower bound jaisa hi hai. Binary Search se search space aadha karo. `arr[mid] >= x` ho to `ans` mein `mid` rakho aur chhota index dhoondhne left jao. Agar `arr[mid] < x` ho to right jao kyunki chhote elements kaam nahi karenge.

**Examples to Prove Idea**:

- `arr = [1,3,5,6]`, `x = 5`:
    - Start: `low=0`, `high=3`, `ans=4`. `mid=1`, `arr[1]=3 < 5` â†’ search right (`low=2`).
    - `mid=2`, `arr[2]=5 >= 5` â†’ set `ans=2`, search left (`high=1`). Stop, return `ans=2`.
- `arr = [1,3,5,6]`, `x = 2`:
    - Start: `low=0`, `high=3`, `ans=4`. `mid=1`, `arr[1]=3 >= 2` â†’ set `ans=1`, search left (`high=0`).
    - `mid=0`, `arr[0]=1 < 2` â†’ search right (`low=1`). Stop, return `ans=1`.
- `arr = [1,3,5,6]`, `x = 7`:
    - All `arr[mid] < 7`, keep searching right, `ans` stays `4` â†’ return `4`.
- *Why It Works*: The sorted property (and no duplicates) ensures we find either `x`â€™s index or the correct insertion point, which is the smallest index where `arr[i] >= x`.

**Intuition**:
Maintain a search space with `low` and `high`. Compute `mid` and check `arr[mid] >= x`:

- If true, `mid` is a candidate (either `arr[mid] == x` or `arr[mid] > x`, indicating insertion point), but search left (`high = mid-1`) for a smaller index.
- If false (`arr[mid] < x`), search right (`low = mid+1`) since elements at or before `mid` are too small.
- Use `ans` to store the smallest valid index, defaulting to `n`. Stop when `low > high`, return `ans`.
The sorted array ensures we can safely eliminate half the elements each step, and no duplicates simplify the logic.

**Dry Run**:

- Input: `arr = [1,3,5,6]`, `x = 2`, `n = 4`.
- Initialize: `low = 0`, `high = 3`, `ans = 4`.
- **Step 1**:
    - Compute: `mid = (0 + 3) / 2 = 1`.
    - Check: `arr[1] = 3 >= 2`. **Reason**: `3` satisfies `>= 2`, so index `1` is a candidate (insertion point, as `3 > 2`). Store `ans = 1` and search left (`high = mid-1 = 0`) to find a potentially smaller index (e.g., if `2` exists earlier).
- **Step 2**:
    - Compute: `mid = (0 + 0) / 2 = 0`.
    - Check: `arr[0] = 1 < 2`. **Reason**: `1` is less than `2`, so index `0` canâ€™t be the answer (nor can it be `x`â€™s index or insertion point). Search right (`low = mid+1 = 1`) to check larger elements.
- **Step 3**:
    - Check: `low = 1 > high = 0`. **Reason**: Search space is exhausted (`low > high`). The last stored `ans = 1` is the smallest index where `arr[1] = 3 >= 2`, indicating `2` should be inserted at index `1` to get `[1,2,3,5,6]`.
- Return: `1`.
- *Hinglish*: Shuru mein `low=0`, `high=3`, `ans=4`. `mid=1` pe `3 >= 2`, to `ans=1` aur left jao (`high=0`) kyunki chhota index ya `x` dhoondhna hai. Phir `mid=0` pe `1 < 2`, to right jao (`low=1`). Ab `low > high`, to `ans=1` return karo kyunki `2` index `1` pe insert hoga.

**Dry Run (Edge Case)**:

- Input: `arr = [1,3,5,6]`, `x = 7`, `n = 4`.
- Initialize: `low = 0`, `high = 3`, `ans = 4`.
- **Step 1**:
    - Compute: `mid = (0 + 3) / 2 = 1`.
    - Check: `arr[1] = 3 < 7`. **Reason**: `3` is less than `7`, so indices `0` to `1` canâ€™t satisfy `>= 7`. Search right (`low = mid+1 = 2`).
- **Step 2**:
    - Compute: `mid = (2 + 3) / 2 = 2`.
    - Check: `arr[2] = 5 < 7`. **Reason**: `5` is less than `7`, so indices `2` and below wonâ€™t work. Search right (`low = mid+1 = 3`).
- **Step 3**:
    - Compute: `mid = (3 + 3) / 2 = 3`.
    - Check: `arr[3] = 6 < 7`. **Reason**: `6` is less than `7`, so index `3` wonâ€™t work. Search right (`low = mid+1 = 4`).
- **Step 4**:
    - Check: `low = 4 > high = 3`. **Reason**: No element `>= 7` found, so `ans` remains `4`, indicating `7` should be inserted at the end (`[1,3,5,6,7]`).
- Return: `4`.
- *Hinglish*: Sab elements `7` se chhote hain. Har baar right gaye kyunki `arr[mid] < 7`. Ant mein `low > high`, to `ans=4` return karo kyunki `7` array ke end pe insert hoga.

**Algorithm**:

1. Initialize `low = 0`, `high = arr.length - 1`, `ans = arr.length`.
2. While `low <= high`:
    - Compute `mid = low + (high - low) / 2`.
    - If `arr[mid] >= x`, set `ans = mid` and search left (`high = mid - 1`).
    - Else (`arr[mid] < x`), search right (`low = mid + 1`).
3. Return `ans`.

**Pseudocode**:

```cpp
function searchInsert(arr, x):
    low = 0
    high = arr.length - 1
    ans = arr.length
    while low <= high:
        mid = low + (high - low) / 2
        if arr[mid] >= x:
            ans = mid
            high = mid - 1
        else:
            low = mid + 1
    return ans

```

**Code**:

```cpp
#include <bits/stdc++.h>
using namespace std;

int searchInsert(vector<int>& arr, int x) {
    int low = 0, high = arr.size() - 1, ans = arr.size();
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] >= x) {
            ans = mid;
            high = mid - 1;
        } else {
            low = mid + 1;
        }
    }
    return ans;
}

```

**Java Equivalent**:

```java
class Solution {
    public int searchInsert(int[] arr, int x) {
        int low = 0, high = arr.length - 1, ans = arr.length;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] >= x) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return ans;
    }
}

```

**Time Complexity (TC)**:

- `O(log n)`: Each iteration halves the search space (e.g., `n=16` takes ~4 steps since `16=2^4`).
- *Why?*: The sorted property allows eliminating half the elements each step, and each comparison is `O(1)`.

**Space Complexity (SC)**:

- `O(1)`: Only uses `low`, `high`, `mid`, and `ans` variables.
- *Why?*: No additional data structures are needed.

**Notes/Observations**:

- *Why this approach?*: Efficient, leverages sorted property, and is identical to Lower Bound. Itâ€™s a standard interview problem (LeetCode #35).
- *Hinglish*: Yeh lower bound ka code hi hai, bas naam alag. `>= x` wala index dhoondho, jo `x` ka index ya insert position hai.
- *Limitation*: Requires sorted array. Use `low + (high - low) / 2` to avoid overflow.
- *Edge Cases*:
    - Single element: Check `arr[0] >= x`, return `0` or `1`.
    - `x` larger than all elements: Returns `n`.
    - `x` smaller than all elements: Returns `0`.
    - No duplicates: Simplifies logic, as `arr[mid] == x` is unique if found.

---

### Key Points for Interview

- **Linear Approach**: Simple but `O(n)`, useful as a baseline to explain why Binary Search is better.
- **Binary Search**: `O(log n)` time, `O(1)` space, preferred for efficiency.
- *Hinglish*: Interview mein pehle linear approach briefly bolo, phir Binary Search ka logic clear karo. `ans` variable aur left/right move ka reason samjhao.
- **Key Insight**: This is Lower Bound (`arr[i] >= x`), returning either `x`â€™s index or insertion point.
- **C++ STL**: `lower_bound(arr.begin(), arr.end(), x) - arr.begin()` gives the same result.
- **Connection to Lower Bound**: The logic is identical, as `arr[i] >= x` finds the correct position for both cases.

### Additional Notes for Beginners

- *Why this approach?*: Binary Search is efficient and teaches how to adapt Lower Bound logic. Linear search is easier but impractical for large `n`.
- *Hinglish*: Linear mein har element check karo, samajh aata hai par slow. Binary Search mein aadha space hatao, fast hai.
- *Practice*:
    - `arr=[1,3,5,6]`, `x=5` â†’ `2`.
    - `arr=[1,3,5,6]`, `x=2` â†’ `1`.
    - `arr=[1,3,5,6]`, `x=7` â†’ `4`.
- *Edge Cases*:
    - Single element array: Check `arr[0]` against `x`.
    - Empty array: Not applicable per constraints (`n >= 1`).
    - Large `n`: Use overflow-safe `mid` calculation.
