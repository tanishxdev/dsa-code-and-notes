# HASHING ‚Äì Basics
---

## 1. WHAT IS HASHING?

### Concept

Hashing is a technique to store and retrieve data in **constant time** by using a special structure called a **hash table**.

It follows two main steps:

1. Pre-store (build / preprocess)
2. Fetch (answer queries in O(1))

Think of hashing as:

> Instead of searching again and again, store the answer once and reuse it instantly.

---

## 2. WHY DO WE NEED HASHING? (Motivation)

Array: `[1, 2, 1, 3, 2]`
Queries: `[1, 3, 4, 2, 10]`

### Brute Force Approach

For each query, scan the whole array.

Time Complexity = O(Q * N)
If N = 10^5 and Q = 10^5 ‚Üí Total = 10^10 operations ‚ùå (Too Slow)

### Hashing Approach

Precompute frequency once, answer in O(1).

Time Complexity = O(N + Q) ‚úÖ Efficient

---

## 3. NUMBER HASHING USING ARRAY

### Approach

* Create frequency array
* Index represents the number
* Value represents frequency

### Example

Array = [1,2,1,3,2]

Hash array after pre-store:
index: 0 1 2 3 4
value: 0 2 2 1 0

Query result = hash[number]

### Code

```cpp
vector<int> freq(100001, 0);
for(int x : arr) freq[x]++;

cout << freq[query];
```

### When to use

‚úÖ Small range numbers
‚ùå Very large numbers like 10^9

---

## 4. CHARACTER HASHING

### Lowercase letters

Mapping: 'a' ‚Üí 0, 'z' ‚Üí 25

```cpp
int hash[26] = {0};
for(char c : s)
    hash[c - 'a']++;
```

### All ASCII characters

```cpp
int hash[256] = {0};
for(char c : s)
    hash[c]++;
```

---

## 5. HASHING LARGE NUMBERS (USING MAPS)

### Why map?

Because we cannot create array of size 10^9.

### Syntax

```cpp
unordered_map<int,int> freq;
for(int x : arr)
    freq[x]++;
```

### Map vs Unordered_map

| Structure     | Time     | Ordered | Worst Case |
| ------------- | -------- | ------- | ---------- |
| map           | O(log N) | Yes     | Safe       |
| unordered_map | O(1) avg | No      | O(N) rare  |

Use unordered_map by default.

---

## 6. TIME COMPLEXITY SELECTION GUIDE

| Scenario      | Best Choice   |
| ------------- | ------------- |
| Small range   | Array Hash    |
| Large values  | unordered_map |
| Sorted needed | map           |
| Fastest       | unordered_map |

---

## 7. COLLISION EXPLAINED SIMPLY

Collision happens when:
Multiple keys map to same index.

Example using modulo:
Keys: 28, 38, 48 ‚Üí all %10 = 8

Solution: Linear Chaining
Each index holds a list of elements.

Worst case ‚Üí O(N)
But happens rarely with good hashing.

---

# PRACTICAL PROBLEM PATTERNS

## 8. COUNT FREQUENCY OF ARRAY ELEMENTS

### Problem

Given array, print frequency of each element

### Code

```cpp
vector<int> arr = {1,2,1,3,2,4};
unordered_map<int,int> freq;

for(int x : arr)
    freq[x]++;

for(auto it : freq)
    cout << it.first << " -> " << it.second << endl;
```

---

## 9. FIND HIGHEST FREQUENCY ELEMENT

```cpp
int maxFreq = 0, element;
for(auto it : freq)
{
    if(it.second > maxFreq)
    {
        maxFreq = it.second;
        element = it.first;
    }
}
```

---

## 10. FIND LOWEST FREQUENCY ELEMENT

```cpp
int minFreq = INT_MAX, element;
for(auto it : freq)
{
    if(it.second < minFreq)
    {
        minFreq = it.second;
        element = it.first;
    }
}
```

---

## 11. CHECK IF ELEMENT EXISTS

```cpp
if(freq.find(x) != freq.end())
    cout << "Exists";
else
    cout << "Does not exist";
```

---

## 12. UNIQUE ELEMENTS COUNT

```cpp
cout << freq.size();
```

---

## 13. REMOVE DUPLICATES USING HASHING

```cpp
unordered_set<int> s;
for(int x : arr)
    s.insert(x);
```

---

## 14. FIRST NON-REPEATING ELEMENT

```cpp
for(int x : arr)
{
    if(freq[x] == 1)
    {
        cout << x;
        break;
    }
}
```

---

## 15. MOST COMMON INTERVIEW QUESTIONS

1. Count frequency of characters
2. Find most frequent number
3. Find first unique element
4. Check if two strings are anagrams
5. Remove duplicates
6. Group anagrams
7. Subarray sum using hashmap
8. Longest substring without repetition

---

# DECISION LOGIC (INTERVIEW READY)

| Problem              | Use           |
| -------------------- | ------------- |
| Frequency            | unordered_map |
| Small range          | Array hash    |
| Sorted output        | map           |
| Strings              | char hash     |
| Performance critical | unordered_map |

---

## FINAL TAKEAWAYS

‚úî Hashing converts O(N^2) ‚Üí O(N)
‚úî Best friend for frequency problems
‚úî Always think: Can I pre-store?
‚úî Use unordered_map unless ordering needed
‚úî Understand collision but don‚Äôt overthink it

---


## Note! üöÄ
This is introductory material. For deeper understanding and implementations, refer to dedicated HASHING folders : `17. Hasshing`. 